/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall ParseATR(__int64 a1, _BYTE *a2, signed int a3);
__int64 __fastcall GetCurrentMode(__int64 a1);
__int64 __fastcall GetSpecificModeProtocol(__int64 a1);
__int64 __fastcall GetfirstOfferedProtocol(__int64 a1);
signed __int64 GetT1CWI();
signed __int64 GetT1BWI();
__int64 __fastcall GetT1IFSC(__int64 a1);
__int64 __fastcall GetDi(__int64 a1);
__int64 __fastcall Getfi(__int64 a1);
__int64 __fastcall GetN(__int64 a1);
__int64 __fastcall GetT1EDC(__int64 a1);
float __fastcall GetEtu(__int64 a1);
__int64 __fastcall GetCWT(__int64 a1, __m128 a2);
__int64 __fastcall GetBWT(__int64 a1);
__int64 __fastcall GetT0CWT(unsigned __int8 *a1);
signed __int64 __fastcall csum_lrc_compute(__int64 a1, __int64 a2, _BYTE *a3);
signed __int64 __fastcall csum_crc_compute(__int64 a1, __int64 a2, _BYTE *a3);
void __fastcall ReaderInitialize(__int64 a1, int a2);
__int64 IFDHCreateChannel();
__int64 __fastcall IFDHCreateChannelByName(unsigned int a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall closeDriver(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall IFDHCloseChannel(unsigned int a1);
__int64 __fastcall IFDHGetCapabilities(unsigned int a1, signed int a2, _DWORD *a3, _BYTE *a4);
__int64 __fastcall IFDHSetCapabilities(unsigned int a1);
__int64 IFDHSetProtocolParameters();
__int64 __fastcall IFDHPowerICC(unsigned int Lun, int Action, __int64 Atr, _DWORD *AtrLength); // idb
signed __int64 __fastcall GetDataBlock(int a1, __int64 a2, _BYTE *a3);
signed __int64 __fastcall EvaluteStatus(unsigned int a1, char a2, _BYTE *a3, char a4);
__int64 __fastcall IFDHTransmitToICC(unsigned int a1, int a2, __int64 a3, unsigned int a4, _WORD *a5, _DWORD *a6);
__int64 __fastcall IFDHControl(unsigned int a1, _BYTE *a2, unsigned __int8 *a3, int a4, void *a5, __int64 a6, _DWORD *a7);
__int64 __fastcall IFDHICCPresence(unsigned int a1);
__int64 __fastcall t1_init(__int64 a1);
signed __int64 __fastcall t1_set_defaults(__int64 a1);
signed __int64 __fastcall t1_set_param(__int64 a1, int a2, int a3);
__int64 __fastcall t1_compute_checksum(__int64 a1, __int64 a2, __int64 a3);
void __fastcall t1_set_checksum(__int64 a1, int a2);
signed __int64 __fastcall t1_block_type(unsigned __int8 a1);
__int64 __fastcall t1_seq(unsigned int a1);
__int64 __fastcall t1_build(__int64 a1, _BYTE *a2, unsigned int a3, unsigned __int8 a4, __int64 a5, _QWORD *a6);
__int64 __fastcall cur_buf_avail(__int64 a1);
__int64 __fastcall cur_buf_head(__int64 a1);
signed __int64 __fastcall t1_rebuild(__int64 a1, _DWORD *a2);
__int64 __fastcall cur_buf_init(_QWORD *a1, __int64 a2, int a3);
void __fastcall cur_buf_set(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall cur_buf_get(__int64 a1, void *a2, size_t a3);
__int64 __fastcall cur_buf_put(__int64 a1, const void *a2, size_t a3);
__int64 __fastcall cur_buf_putc(__int64 a1, char a2);
void __fastcall tds_log_msg();
void tds_log_xxd();
void __fastcall lock_mutex(__int64 a1);
void __fastcall unlock_mutex(__int64 a1);
void __fastcall cancel_lock_mutex(__int64 a1);
void __fastcall cancel_unlock_mutex(__int64 a1);
__int64 __fastcall PCSC_GetCardStatus(__int64 device, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6); // idb
__int64 __fastcall read_response(__int64 a1, _BYTE *a2, __int64 a3, unsigned int a4, unsigned int *a5, __int64 a6);
__int64 __fastcall write_command(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall ABNED_Vendor_Transmit_Receive(__int64 a1, __int64 a2, __int64 a3, int a4, _BYTE *a5, __int64 a6, unsigned int a7, unsigned int *a8);
__int64 __fastcall PCSC_CAP_SendAndReceive(__int64 a1, __int64 a2, unsigned int a3, _BYTE *a4, _DWORD *a5, __int64 a6);
__int64 __fastcall PCSC_ABNTransmit(__int64 a1, __int64 a2, unsigned int a3, _BYTE *a4, _DWORD *a5);
__int64 __fastcall CardPowerOn(__int64 a1);
__int64 __fastcall CardPowerOff(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall PCSC_CardPower(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall T0CmdParsing(__int64 a1, unsigned int a2, _DWORD *a3);
void *__fastcall Read_NamedPipeThreadRoutine(void *a1);
// __int64 __usercall UsbIo_Write@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r9>);
// __int64 __usercall UsbIo_CloseDeviceAndInterface@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>);
__int64 __fastcall Notify_Close_NamedPipe(__int64 a1);
void __fastcall UsbIo_AsynReadCompletionRoutine(__int64 a1, signed int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
// void __usercall UsbIo_SetAsynRead(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<r9>);
__int64 __fastcall UsbIo_Read(__int64 a1, _QWORD *a2);
void *__fastcall UsbIo_ThreadRoutine(void *a1);
void __fastcall MySleepCallBack(__int64 a1, __int64 a2, int a3, __int64 a4);
void *__fastcall UsbIo_DetectSleepNotification(void *a1);
// __int64 __usercall DetectSleepNotification@<rax>(void *a1@<rdi>, struct _opaque_pthread_t *a2@<rax>);
// __int64 __usercall UsbIo_CreateThread@<rax>(void *a1@<rdi>, struct _opaque_pthread_t *a2@<rax>);
// __int64 __usercall Read_Create_NamedPipeThread@<rax>(void *a1@<rdi>, struct _opaque_pthread_t *a2@<rax>);
void __fastcall UsbIo_GetPipes(unsigned int a1, __int64 a2, __int64 a3);
void __fastcall UsbIo_GetInterface(unsigned int a1, __int64 a2, __int64 a3);
__int64 __fastcall UsbIo_GetDevice(unsigned int a1, __int64 a2, __int64 a3);
__int64 __fastcall UsbIo_Open(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall UsbIo_Close(__int64 a1);
// __int64 __fastcall CFDictionaryAddValue(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall CFDictionarySetValue(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall CFNumberCreate(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall CFRelease(_QWORD); weak
// __int64 __fastcall CFRetain(_QWORD, _QWORD); weak
// __int64 __fastcall CFRunLoopAddSource(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall CFRunLoopGetCurrent(_QWORD); weak
// __int64 __fastcall CFRunLoopRun(_QWORD, _QWORD); weak
// __int64 __fastcall CFUUIDGetConstantUUIDWithBytes(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall CFUUIDGetUUIDBytes(_QWORD); weak
// __int64 __fastcall IOAllowPowerChange(_QWORD, _QWORD); weak
// __int64 __fastcall IOCreatePlugInInterfaceForService(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall IODestroyPlugInInterface(_QWORD); weak
// __int64 __fastcall IOIteratorNext(_QWORD, _QWORD); weak
// __int64 __fastcall IOMasterPort(_QWORD, _QWORD); weak
// __int64 __fastcall IONotificationPortCreate(_QWORD); weak
// __int64 __fastcall IONotificationPortGetRunLoopSource(_QWORD); weak
// __int64 __fastcall IOObjectRelease(_QWORD); weak
// __int64 __fastcall IORegisterForSystemPower(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall IOServiceAddMatchingNotification(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall IOServiceGetMatchingServices(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall IOServiceMatching(_QWORD); weak
// __int64 __fastcall __bzero(_QWORD, _QWORD); weak
// int *__error(void);
// __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __cdecl close(int);
// void __cdecl free(void *);
// kern_return_t __cdecl mach_port_deallocate(ipc_space_t task, mach_port_name_t name);
// void *__cdecl malloc(size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// int __cdecl mkfifo(const char *, mode_t);
// int open(const char *, int, ...);
// int printf(const char *, ...);
// int __cdecl pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *);
// int __cdecl pthread_cond_signal(pthread_cond_t *);
// int __cdecl pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
// int __cdecl pthread_create(pthread_t *, const pthread_attr_t *, void *(__cdecl *)(void *), void *);
// int __cdecl pthread_mutex_destroy(pthread_mutex_t *);
// int __cdecl pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *);
// int __cdecl pthread_mutex_lock(pthread_mutex_t *);
// int __cdecl pthread_mutex_unlock(pthread_mutex_t *);
// int __cdecl putchar(int);
// ssize_t __cdecl read(int, void *, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// mode_t __cdecl umask(mode_t);
// int __cdecl usleep(useconds_t);
// ssize_t __cdecl write(int, const void *, size_t);

//-------------------------------------------------------------------------
// Data declarations

void *__ptr32 off_324C[5] =
{
  (void *__ptr32 )0xFFFFFBF1LL,
  (void *__ptr32 )0xFFFFFBFCLL,
  (void *__ptr32 )0xFFFFFC2CLL,
  (void *__ptr32 )0xFFFFFB35LL,
  (void *__ptr32 )0xFFFFFB35LL
}; // weak
signed int fi[16] = { 372, 372, 558, 744, 1116, 1488, 1860, 1, 1, 512, 768, 1024, 1536, 2048, 1, 1 }; // idb
signed int di[16] = { 1, 1, 2, 4, 8, 16, 32, 1, 12, 20, 1, 1, 1, 1, 1, 1 }; // idb
_WORD crctab[294] =
{
  0,
  4489,
  8978,
  12955,
  17956,
  22445,
  25910,
  29887,
  35912,
  40385,
  44890,
  48851,
  51820,
  56293,
  59774,
  63735,
  4225,
  264,
  13203,
  8730,
  22181,
  18220,
  30135,
  25662,
  40137,
  36160,
  49115,
  44626,
  56045,
  52068,
  63999,
  59510,
  8450,
  12427,
  528,
  5017,
  26406,
  30383,
  17460,
  21949,
  44362,
  48323,
  36440,
  40913,
  60270,
  64231,
  51324,
  55797,
  12675,
  8202,
  4753,
  792,
  30631,
  26158,
  21685,
  17724,
  48587,
  44098,
  40665,
  36688,
  64495,
  60006,
  55549,
  51572,
  16900,
  21389,
  24854,
  28831,
  1056,
  5545,
  10034,
  14011,
  52812,
  57285,
  60766,
  64727,
  34920,
  39393,
  43898,
  47859,
  21125,
  17164,
  29079,
  24606,
  5281,
  1320,
  14259,
  9786,
  57037,
  53060,
  64991,
  60502,
  39145,
  35168,
  48123,
  43634,
  25350,
  29327,
  16404,
  20893,
  9506,
  13483,
  1584,
  6073,
  61262,
  65223,
  52316,
  56789,
  43370,
  47331,
  35448,
  39921,
  29575,
  25102,
  20629,
  16668,
  13731,
  9258,
  5809,
  1848,
  65487,
  60998,
  56541,
  52564,
  47595,
  43106,
  39673,
  35696,
  33800,
  38273,
  42778,
  46739,
  49708,
  54181,
  57662,
  61623,
  2112,
  6601,
  11090,
  15067,
  20068,
  24557,
  28022,
  31999,
  38025,
  34048,
  47003,
  42514,
  53933,
  49956,
  61887,
  57398,
  6337,
  2376,
  15315,
  10842,
  24293,
  20332,
  32247,
  27774,
  42250,
  46211,
  34328,
  38801,
  58158,
  62119,
  49212,
  53685,
  10562,
  14539,
  2640,
  7129,
  28518,
  32495,
  19572,
  24061,
  46475,
  41986,
  38553,
  34576,
  62383,
  57894,
  53437,
  49460,
  14787,
  10314,
  6865,
  2904,
  32743,
  28270,
  23797,
  19836,
  50700,
  55173,
  58654,
  62615,
  32808,
  37281,
  41786,
  45747,
  19012,
  23501,
  26966,
  30943,
  3168,
  7657,
  12146,
  16123,
  54925,
  50948,
  62879,
  58390,
  37033,
  33056,
  46011,
  41522,
  23237,
  19276,
  31191,
  26718,
  7393,
  3432,
  16371,
  11898,
  59150,
  63111,
  50204,
  54677,
  41258,
  45219,
  33336,
  37809,
  27462,
  31439,
  18516,
  23005,
  11618,
  15595,
  3696,
  8185,
  63375,
  58886,
  54429,
  50452,
  45483,
  40994,
  37561,
  33584,
  31687,
  27214,
  22741,
  18780,
  15843,
  11370,
  7921,
  3960,
  41984,
  3080,
  57092,
  20480,
  50,
  1188,
  1792,
  160,
  0,
  377,
  0,
  1188,
  2572,
  37587,
  240,
  294,
  0,
  256,
  0,
  0,
  0,
  0,
  0,
  0,
  41984,
  4,
  40971,
  0,
  2051,
  0,
  16,
  1,
  4736,
  256,
  4736,
  258,
  4736,
  259
}; // idb
_BYTE ReaderData[896]; // idb
__int64 gBuffer; // weak
__int64 gNotifyPort; // weak
_UNKNOWN gSendAsynReadIter; // weak
mach_port_name_t masterPort; // idb
char gContion; // weak
int root_port; // weak
// extern _UNKNOWN kCFAllocatorDefault; weak
// extern _UNKNOWN kCFRunLoopCommonModes; weak
// extern _UNKNOWN kCFRunLoopDefaultMode; weak
// extern _UNKNOWN __stack_chk_guard; weak
// extern mach_port_t mach_task_self_;


//----- (0000000000000AC0) ----------------------------------------------------
__int64 __fastcall ParseATR(__int64 a1, _BYTE *a2, signed int a3)
{
  signed int v3; // er12
  _BYTE *v4; // r15
  unsigned int v5; // er14
  char v7; // al
  char v8; // dl
  signed __int64 v9; // rax
  unsigned __int64 v10; // rcx
  int v11; // esi
  signed int v12; // esi
  char v13; // si
  char v14; // si
  char v15; // si
  signed __int64 v16; // rdx
  char v17; // cl
  char v18; // cl

  v3 = a3;
  v4 = a2;
  __bzero(a1 + 288, 160LL);
  v5 = -11;
  if ( v3 < 2 )
    return v5;
  v7 = *a2;
  *(_BYTE *)(a1 + 328) = *a2;
  *(_BYTE *)(a1 + 288) = v7;
  if ( v7 != 63 && v7 != 59 )
  {
    if ( v7 != 3 )
      return v5;
    *(_BYTE *)(a1 + 328) = 63;
  }
  v8 = a2[1];
  *(_BYTE *)(a1 + 329) = v8;
  *(_BYTE *)(a1 + 289) = v8;
  *(_DWORD *)(a1 + 444) = v8 & 0xF;
  *(_BYTE *)(a1 + 421) = 0;
  LODWORD(v9) = 1;
  v10 = 0LL;
  while ( 1 )
  {
    if ( v8 & 0x10 )
    {
      if ( (signed int)v9 >= v3 )
        return v5;
      v9 = (signed int)v9 + 1LL;
      v13 = v4[v9];
      *(_BYTE *)(a1 + 8 * v10 + 364) = v13;
      *(_BYTE *)(a1 + 8 * v10 + 365) = 1;
      *(_BYTE *)(a1 + v9 + 288) = v13;
    }
    else
    {
      *(_BYTE *)(a1 + 8 * v10 + 365) = 0;
    }
    if ( v8 & 0x20 )
    {
      if ( (signed int)v9 >= v3 )
        return v5;
      v9 = (signed int)v9 + 1LL;
      v14 = v4[v9];
      *(_BYTE *)(a1 + 8 * v10 + 366) = v14;
      *(_BYTE *)(a1 + 8 * v10 + 367) = 1;
      *(_BYTE *)(a1 + v9 + 288) = v14;
    }
    else
    {
      *(_BYTE *)(a1 + 8 * v10 + 367) = 0;
    }
    if ( v8 & 0x40 )
    {
      if ( (signed int)v9 >= v3 )
        return v5;
      v9 = (signed int)v9 + 1LL;
      v15 = v4[v9];
      *(_BYTE *)(a1 + 8 * v10 + 368) = v15;
      *(_BYTE *)(a1 + 8 * v10 + 369) = 1;
      *(_BYTE *)(a1 + v9 + 288) = v15;
    }
    else
    {
      *(_BYTE *)(a1 + 8 * v10 + 369) = 0;
    }
    if ( v8 >= 0 )
      break;
    if ( (signed int)v9 >= v3 )
      return v5;
    v9 = (signed int)v9 + 1LL;
    v8 = v4[v9];
    *(_BYTE *)(a1 + 8 * v10 + 370) = v8;
    *(_BYTE *)(a1 + 8 * v10 + 371) = 1;
    *(_BYTE *)(a1 + v9 + 288) = v8;
    v11 = v8 & 0xF;
    *(_DWORD *)(a1 + 4 * v10 + 336) = v11;
    *(_BYTE *)(a1 + 421) = (_BYTE)v11 != 0;
    if ( v10 > 6 )
      return v5;
    ++v10;
    if ( v8 & 0xF )
    {
      if ( v11 == 1 )
      {
        v12 = 2;
        goto LABEL_14;
      }
    }
    else
    {
      v12 = 1;
LABEL_14:
      *(_DWORD *)(a1 + 332) |= v12;
    }
  }
  if ( !(_DWORD)v10 )
    *(_BYTE *)(a1 + 332) |= 1u;
  *(_BYTE *)(a1 + 8 * v10 + 371) = 0;
  *(_DWORD *)(a1 + 424) = v10 + 1;
  if ( *(_DWORD *)(a1 + 444) < 0 )
  {
LABEL_34:
    if ( *(_BYTE *)(a1 + 421) )
    {
      if ( (signed int)v9 >= v3 )
        return v5;
      v9 = (signed int)v9 + 1LL;
      v18 = v4[v9];
      *(_BYTE *)(a1 + 420) = v18;
      *(_BYTE *)(a1 + v9 + 288) = v18;
    }
    *(_DWORD *)(a1 + 324) = v9;
    v5 = 0;
    tds_log_msg();
    return v5;
  }
  v9 = (signed int)v9;
  v16 = -1LL;
  while ( v9 < v3 )
  {
    v17 = v4[v9 + 1];
    *(_BYTE *)(a1 + v16 + 429) = v17;
    *(_BYTE *)(a1 + v9++ + 289) = v17;
    if ( ++v16 >= *(signed int *)(a1 + 444) )
      goto LABEL_34;
  }
  return v5;
}
// 7224: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);

//----- (0000000000000D1B) ----------------------------------------------------
__int64 __fastcall GetCurrentMode(__int64 a1)
{
  return (unsigned int)(*(_BYTE *)(a1 + 85) < 1u) + 1;
}

//----- (0000000000000D2D) ----------------------------------------------------
__int64 __fastcall GetSpecificModeProtocol(__int64 a1)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 85) )
    LOBYTE(result) = *(_BYTE *)(a1 + 84) & 0xF;
  else
    LOBYTE(result) = 20;
  return (unsigned __int8)result;
}

//----- (0000000000000D45) ----------------------------------------------------
__int64 __fastcall GetfirstOfferedProtocol(__int64 a1)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 83) )
    LOBYTE(result) = *(_BYTE *)(a1 + 82) & 0xF;
  else
    LOBYTE(result) = 0;
  return (unsigned __int8)result;
}

//----- (0000000000000D5D) ----------------------------------------------------
signed __int64 GetT1CWI()
{
  return 5LL;
}

//----- (0000000000000D68) ----------------------------------------------------
signed __int64 GetT1BWI()
{
  return 4LL;
}

//----- (0000000000000D73) ----------------------------------------------------
__int64 __fastcall GetT1IFSC(__int64 a1)
{
  signed __int64 v1; // rdx
  unsigned __int8 v2; // si
  signed __int64 v3; // rcx

  v1 = *(signed int *)(a1 + 136);
  v2 = 32;
  if ( v1 >= 2 )
  {
    v3 = 1LL;
    while ( !*(_BYTE *)(a1 + 8 * v3 + 83) || (*(_BYTE *)(a1 + 8 * v3 + 82) & 0xF) != 1 )
    {
      if ( ++v3 >= v1 )
        return v2;
    }
    if ( *(_BYTE *)(a1 + 8 * v3 + 85) )
      v2 = *(_BYTE *)(a1 + 8 * v3 + 84);
  }
  return v2;
}

//----- (0000000000000DB9) ----------------------------------------------------
__int64 __fastcall GetDi(__int64 a1)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 77) )
    LOBYTE(result) = *(_BYTE *)(a1 + 76) & 0xF;
  else
    LOBYTE(result) = 1;
  return (unsigned __int8)result;
}

//----- (0000000000000DD1) ----------------------------------------------------
__int64 __fastcall Getfi(__int64 a1)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 77) )
    LOBYTE(result) = *(_BYTE *)(a1 + 76) >> 4;
  else
    LOBYTE(result) = 1;
  return (unsigned __int8)result;
}

//----- (0000000000000DEA) ----------------------------------------------------
__int64 __fastcall GetN(__int64 a1)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 81) )
    LOBYTE(result) = *(_BYTE *)(a1 + 80);
  else
    LOBYTE(result) = 0;
  return (unsigned __int8)result;
}

//----- (0000000000000E00) ----------------------------------------------------
__int64 __fastcall GetT1EDC(__int64 a1)
{
  signed __int64 v1; // rcx
  __int64 result; // rax
  signed __int64 v3; // rbx
  __int64 v4; // r9

  v1 = *(signed int *)(a1 + 136);
  LOBYTE(result) = 1;
  if ( v1 >= 2 )
  {
    v3 = 1LL;
    while ( !*(_BYTE *)(a1 + 8 * v3 + 83) || (*(_BYTE *)(a1 + 8 * v3 + 82) & 0xF) != 1 )
    {
      if ( ++v3 >= v1 )
        return (unsigned __int8)result;
    }
    if ( *(_BYTE *)(a1 + 8 * v3 + 89) )
    {
      v4 = *(unsigned __int8 *)(a1 + 8 * v3 + 88);
      tds_log_msg();
      LOBYTE(result) = (*(_BYTE *)(a1 + 8 * v3 + 88) & 1) + 1;
    }
  }
  return (unsigned __int8)result;
}

//----- (0000000000000E82) ----------------------------------------------------
float __fastcall GetEtu(__int64 a1)
{
  unsigned __int8 v1; // bl
  __int64 v2; // rax
  unsigned __int8 v3; // bl
  signed int v4; // ecx
  float result; // xmm0_4

  if ( *(_BYTE *)(a1 + 77) )
  {
    v1 = *(_BYTE *)(a1 + 76);
    LOBYTE(v2) = v1 >> 4;
    v3 = v1 & 0xF;
    if ( !(v3 | (unsigned __int8)v2) )
    {
      v3 = 0;
      tds_log_msg();
      LOBYTE(v2) = 0;
    }
  }
  else
  {
    v3 = 1;
    LOBYTE(v2) = 1;
  }
  v2 = (unsigned __int8)v2;
  v4 = 15999;
  if ( _bittest(&v4, (unsigned __int8)v2) )
    result = (float)((float)fi[v2] / (float)di[v3]) / 3000000.0;
  else
    result = 0.000124;
  return result;
}

//----- (0000000000000F14) ----------------------------------------------------
__int64 __fastcall GetCWT(__int64 a1, __m128 a2)
{
  __m128 v2; // xmm2
  __m128 v3; // xmm3
  __m128 v4; // xmm3

  *(double *)a2.m128_u64 = GetEtu(a1) * 43.0 * 1000.0 + 0.5;
  a2.m128_f32[0] = *(double *)a2.m128_u64;
  v2.m128_f32[0] = 1.0 - a2.m128_f32[0];
  v3.m128_i32[0] = 0;
  v4 = _mm_cmplt_ss(v3, v2);
  return (unsigned int)(signed int)COERCE_FLOAT(*(unsigned __int128 *)&_mm_andnot_ps(v4, a2) | v4.m128_i32[0] & 0x3F800000);
}

//----- (0000000000000F63) ----------------------------------------------------
__int64 __fastcall GetBWT(__int64 a1)
{
  float v1; // xmm0_4

  v1 = ((float)(GetEtu(a1) * 11.0) + 1.90464) * 1000.0;
  return (unsigned int)(signed int)v1;
}

//----- (0000000000000F92) ----------------------------------------------------
__int64 __fastcall GetT0CWT(unsigned __int8 *a1)
{
  unsigned __int64 v1; // rax
  float v2; // xmm0_4

  if ( a1[77] )
    v1 = (unsigned __int64)a1[76] >> 4;
  else
    v1 = 1LL;
  if ( a1[89] )
    v2 = (float)(960 * a1[88]);
  else
    v2 = 9600.0;
  return (unsigned int)(signed int)(float)((float)((float)((float)fi[v1] * v2) / 3000000.0) * 1000.0);
}

//----- (0000000000000FEF) ----------------------------------------------------
signed __int64 __fastcall csum_lrc_compute(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 v3; // rcx
  char v4; // al

  if ( a2 )
  {
    v3 = 0LL;
    v4 = 0;
    do
      v4 ^= *(_BYTE *)(a1 + v3++);
    while ( a2 != v3 );
  }
  else
  {
    v4 = 0;
  }
  if ( a3 )
    *a3 = v4;
  return 1LL;
}

//----- (0000000000001019) ----------------------------------------------------
signed __int64 __fastcall csum_crc_compute(__int64 a1, __int64 a2, _BYTE *a3)
{
  signed __int16 v3; // ax
  __int64 v4; // rcx

  v3 = -1;
  if ( a2 )
  {
    v4 = 0LL;
    do
      v3 = HIBYTE(v3) ^ crctab[*(unsigned __int8 *)(a1 + v4++) ^ (unsigned __int8)v3];
    while ( a2 != v4 );
  }
  if ( a3 )
  {
    *a3 = HIBYTE(v3);
    a3[1] = v3;
  }
  return 2LL;
}

//----- (0000000000001060) ----------------------------------------------------
void __fastcall ReaderInitialize(__int64 a1, int a2)
{
  pthread_mutex_t *v2; // rax

  *(_QWORD *)(a1 + 160) = 34359738376LL;
  *(_BYTE *)(a1 + 22) = 0;
  *(_WORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)a1 = 1;
  *(_BYTE *)(a1 + 26) = 0;
  tds_log_msg();
  tds_log_msg();
  tds_log_msg();
  v2 = (pthread_mutex_t *)malloc(0x78uLL);
  *(_QWORD *)(a1 + 176) = v2;
  if ( pthread_mutex_init(v2, 0LL) )
  {
    tds_log_msg();
    free(*(void **)(a1 + 176));
  }
  if ( pthread_cond_init((pthread_cond_t *)(*(_QWORD *)(a1 + 176) + 64LL), 0LL) )
  {
    tds_log_msg();
    pthread_mutex_destroy(*(pthread_mutex_t **)(a1 + 176));
    free(*(void **)(a1 + 176));
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0LL) )
    tds_log_msg();
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 96), 0LL) )
    tds_log_msg();
}

//----- (0000000000001224) ----------------------------------------------------
__int64 IFDHCreateChannel()
{
  return 0LL;
}

//----- (000000000000122C) ----------------------------------------------------
__int64 __fastcall IFDHCreateChannelByName(unsigned int a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  _BYTE *device; // r13
  struct _opaque_pthread_t *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned int v12; // er15
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  struct _opaque_pthread_t *v17; // rax
  struct _opaque_pthread_t *v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9

  v6 = a1 >> 16;
  tds_log_msg();
  tds_log_msg();
  tds_log_msg();
  device = &ReaderData[448 * v6];
  ReaderInitialize((__int64)device, v6);
  v12 = 612;
  if ( (unsigned __int8)DetectSleepNotification(device, v8) )
  {
    if ( (unsigned __int8)UsbIo_Open((__int64)ReaderData, (__int64)device, a2, v9, v10, v11) )
    {
      ReaderData[448 * v6 + 21] = 1;
      v17 = (struct _opaque_pthread_t *)PCSC_GetCardStatus((__int64)device, (__int64)device, v13, v14, v15, v16);
      if ( !(_BYTE)v17 )
      {
        UsbIo_Close((__int64)device);
        return v12;
      }
      v18 = (struct _opaque_pthread_t *)UsbIo_CreateThread(device, v17);
      if ( !(_BYTE)v18 || !(unsigned __int8)Read_Create_NamedPipeThread(device, v18) )
      {
        closeDriver(a1, (__int64)device, v19, v20, v21, v22);
        return v12;
      }
      v12 = 0;
    }
    tds_log_msg();
  }
  return v12;
}

//----- (000000000000139C) ----------------------------------------------------
__int64 __fastcall closeDriver(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 v6; // rbx
  char v7; // al

  v6 = 448LL * (a1 >> 16);
  if ( *(_DWORD *)&ReaderData[v6 + 228] == 2 )
  {
    if ( (unsigned int)PCSC_CardPower((__int64)&ReaderData[v6], 1LL, a3, a4, a5, a6) )
      tds_log_msg();
    *(_DWORD *)&ReaderData[v6 + 324] = 0;
  }
  v7 = UsbIo_Close((__int64)&ReaderData[v6]);
  LOBYTE(v6) = 1;
  if ( !v7 )
  {
    LODWORD(v6) = 0;
    tds_log_msg();
  }
  return (unsigned int)v6;
}

//----- (000000000000144C) ----------------------------------------------------
__int64 __fastcall IFDHCloseChannel(unsigned int a1)
{
  unsigned int v1; // er14
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9

  v1 = 0;
  tds_log_msg();
  if ( (unsigned __int8)closeDriver(a1, (__int64)"%s:%d:%s() IFDHCloseChannel Lun = 0x%04x%04x IN", v2, v3, v4, v5) )
  {
    tds_log_msg();
  }
  else
  {
    tds_log_msg();
    v1 = 612;
  }
  return v1;
}

//----- (00000000000014FA) ----------------------------------------------------
__int64 __fastcall IFDHGetCapabilities(unsigned int a1, signed int a2, _DWORD *a3, _BYTE *a4)
{
  _BYTE *v4; // r14
  _DWORD *v5; // r15
  signed __int64 v6; // rbx
  unsigned int v7; // ebx

  v4 = a4;
  v5 = a3;
  tds_log_msg();
  if ( a2 <= 0xFAD )
  {
    if ( a2 == 0x303 )
    {
      v6 = 448LL * (a1 >> 16);
      *v5 = *(_DWORD *)&ReaderData[v6 + 324];
      tds_log_msg();
      if ( *v5 )
        memcpy(v4, &ReaderData[v6 + 288], (unsigned int)*v5);
      goto LABEL_12;
    }
    if ( a2 == 4013 )
    {
      tds_log_msg();
      if ( *v5 )
      {
        *v5 = 1;
        *v4 = 0;
      }
      goto LABEL_12;
    }
LABEL_14:
    tds_log_msg();
    return 600;
  }
  if ( a2 == 4014 )
  {
    tds_log_msg();
    *v5 = 1;
    *v4 = 1;
  }
  else
  {
    if ( a2 != 4015 )
      goto LABEL_14;
    tds_log_msg();
    *v5 = 1;
    *v4 = 2;
  }
LABEL_12:
  v7 = 0;
  tds_log_msg();
  return v7;
}

//----- (00000000000016E9) ----------------------------------------------------
__int64 __fastcall IFDHSetCapabilities(unsigned int a1)
{
  tds_log_msg();
  tds_log_msg();
  return 0LL;
}

//----- (0000000000001756) ----------------------------------------------------
__int64 IFDHSetProtocolParameters()
{
  tds_log_msg();
  tds_log_msg();
  tds_log_msg();
  return 0LL;
}

//----- (00000000000017E4) ----------------------------------------------------
__int64 __fastcall IFDHPowerICC(unsigned int Lun, int Action, __int64 Atr, _DWORD *AtrLength)
{
  __int64 v4; // r13
  signed __int64 v5; // r12
  _BYTE *v6; // r14
  unsigned int v7; // er12
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  _BYTE *v17; // rbx
  size_t v18; // rdx
  _DWORD *v19; // [rsp+8h] [rbp-38h]
  signed __int64 v20; // [rsp+10h] [rbp-30h]

  v19 = AtrLength;
  v4 = Atr;
  tds_log_msg();
  *(_QWORD *)(v4 + 24) = 0LL;
  *(_QWORD *)(v4 + 16) = 0LL;
  *(_QWORD *)(v4 + 8) = 0LL;
  *(_QWORD *)v4 = 0LL;
  *(_BYTE *)(v4 + 32) = 0;
  v5 = 0x1C0LL * (Lun >> 16);
  v6 = &ReaderData[v5];
  lock_mutex((__int64)&ReaderData[v5]);
  v20 = 0x1C0LL * (Lun >> 16);
  if ( Action == 502 )
  {
    tds_log_msg();
LABEL_6:
    t1_init((__int64)&ReaderData[v5 + 240]);
    ReaderData[v5 + 8] = 1;
    v7 = 617;
    switch ( (unsigned int)PCSC_CardPower((__int64)v6, 0LL, v8, v9, v10, v11) + 6 )
    {
      case 0u:
        tds_log_msg();
        goto LABEL_10;
      case 1u:
      case 7u:
        goto LABEL_12;
      case 6u:
        v17 = &ReaderData[v20 + 288];
        v18 = *(unsigned int *)&ReaderData[v20 + 324];
        *v19 = v18;
        memcpy((void *)v4, v17, v18);
        *(v17 - 266) = 0;
        *((_DWORD *)v17 - 10) = (unsigned __int8)GetT1IFSC((__int64)v17);
        v7 = 0;
        goto LABEL_13;
      default:
        tds_log_msg();
        v7 = 608;
        break;
    }
    goto LABEL_12;
  }
  if ( Action == 0x1F5 )
  {
    v7 = 0;
    tds_log_msg();
    ReaderData[v20 + 8] = 1;
    if ( !(unsigned int)PCSC_CardPower((__int64)v6, 1LL, v12, v13, v14, v15) )
    {
      *(_DWORD *)&ReaderData[v20 + 324] = 0;
      goto LABEL_14;
    }
    tds_log_msg();
    *(_DWORD *)&ReaderData[v20 + 324] = 0;
LABEL_10:
    v7 = 612;
  }
  else
  {
    v7 = 614;
    if ( Action == 500 )
    {
      tds_log_msg();
      v5 = 0x1C0LL * (Lun >> 16);
      goto LABEL_6;
    }
  }
LABEL_12:
  *(_QWORD *)(v4 + 24) = 0LL;
  *(_QWORD *)(v4 + 16) = 0LL;
  *(_QWORD *)(v4 + 8) = 0LL;
  *(_QWORD *)v4 = 0LL;
  *(_BYTE *)(v4 + 32) = 0;
  *(_DWORD *)&ReaderData[v20 + 324] = 0;
LABEL_13:
  tds_log_msg();
LABEL_14:
  unlock_mutex((__int64)v6);
  tds_log_msg();
  return v7;
}

//----- (0000000000001B38) ----------------------------------------------------
signed __int64 __fastcall GetDataBlock(int a1, __int64 a2, _BYTE *a3)
{
  int v3; // er8
  __int64 v4; // r10
  char v5; // cl
  char v6; // di
  int v7; // er8
  signed __int64 result; // rax
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rcx
  char v12; // r9
  unsigned __int8 v13; // r11

  v3 = a1;
  v4 = *(unsigned __int8 *)(a2 + a1 + 1);
  v5 = *(_BYTE *)(a2 + a1);
  *a3 = v5;
  v6 = *(_BYTE *)(a2 + a1 + 1);
  a3[1] = v6;
  v7 = v3 + 2;
  result = 0xFFFFFFFFLL;
  if ( v5 != 1 )
  {
    if ( v5 )
      return result;
    if ( (_BYTE)v4 )
    {
      v9 = v7 + a2;
      v10 = 0LL;
      do
      {
        a3[v10 + 2] = *(_BYTE *)(v9 + v10);
        ++v10;
      }
      while ( v4 != v10 );
      v7 += v10;
    }
    return (unsigned int)v7;
  }
  if ( v6 == 68 && (_BYTE)v4 )
  {
    v11 = 0LL;
    do
    {
      v13 = *(_BYTE *)(a2 + v7);
      if ( v13 >= 0x20u && ((v13 & 0x80u) == 0 || v13 >= 0x90u) )
      {
        v12 = 0;
        if ( v13 != -83 && (unsigned __int8)(v13 + 110) >= 0xFu )
        {
          a3[v11 + 2] = v13;
          ++v7;
          v12 = 1;
        }
      }
      else
      {
        v12 = 0;
      }
      ++v11;
    }
    while ( v4 != v11 );
    if ( v12 )
      return (unsigned int)v7;
  }
  return result;
}

//----- (0000000000001BE3) ----------------------------------------------------
signed __int64 __fastcall EvaluteStatus(unsigned int a1, char a2, _BYTE *a3, char a4)
{
  unsigned int v4; // ebx
  signed __int64 result; // rax
  char v6; // al
  unsigned __int64 v7; // rax
  signed __int64 v8; // rcx
  signed __int64 v9; // rcx

  if ( a1 )
  {
    v4 = a1;
    tds_log_msg();
  }
  else
  {
    v4 = -536862718;
    switch ( a2 )
    {
      case 1:
        if ( a4 == 1 )
        {
          v4 = 0;
          if ( *a3 == 1 )
            return v4;
        }
        goto LABEL_17;
      case 2:
      case 3:
      case 4:
      case 5:
        result = 0xE0100000LL;
        if ( a4 == a2 )
          result = 0LL;
        return result;
      case 6:
        return 0xA010000A;
      case 7:
        return v4;
      case 8:
        if ( !a3 )
          goto LABEL_17;
        v4 = 0xA0100013;
        v6 = *a3 - 1;
        switch ( *a3 )
        {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 0x10:
          case 0x11:
          case 0x12:
          case 0x13:
          case 0x14:
          case 0x15:
          case 0x16:
          case 0x17:
          case 0x18:
          case 0x20:
          case 0x22:
          case 0x23:
          case 0x26:
          case 0x27:
          case 0x29:
            v4 = 0xA010001C;
            break;
          case 0xA:
          case 0xB:
          case 0xC:
          case 0xD:
          case 0xE:
          case 0xF:
          case 0x1A:
          case 0x1B:
          case 0x1C:
          case 0x1D:
          case 0x1E:
          case 0x1F:
          case 0x2A:
          case 0x2B:
          case 0x2C:
          case 0x2D:
          case 0x2E:
          case 0x2F:
          case 0x35:
          case 0x36:
          case 0x37:
          case 0x38:
          case 0x39:
          case 0x3A:
          case 0x3B:
          case 0x3C:
          case 0x3D:
          case 0x3E:
          case 0x3F:
            goto LABEL_25;
          case 0x19:
          case 0x21:
          case 0x25:
          case 0x28:
            v4 = 0xE0100003;
            break;
          case 0x24:
            v4 = 0xE0100002;
            break;
          case 0x30:
          case 0x31:
          case 0x32:
          case 0x33:
          case 0x34:
          case 0x40:
          case 0x41:
          case 0x42:
          case 0x43:
          case 0x44:
          case 0x45:
          case 0x46:
          case 0x47:
          case 0x48:
            return v4;
          default:
            if ( (unsigned __int8)(v6 + 128) > 9u )
            {
              if ( v6 != 114 )
LABEL_25:
                v4 = 0xA0100014;
            }
            else
            {
              v7 = (unsigned __int8)(v6 + 128);
              v8 = 979LL;
              if ( _bittest64(&v8, v7) )
              {
                v4 = 0xE0100001;
              }
              else
              {
                v9 = 40LL;
                if ( _bittest64(&v9, v7) )
                  v4 = 0xA0100001;
                else
                  v4 = 0xA010006C;
              }
            }
            break;
        }
        break;
      case 10:
      case 11:
        v4 = 0xE0002001;
        break;
      default:
LABEL_17:
        v4 = 0xE0100000;
        break;
    }
  }
  return v4;
}

//----- (0000000000001E5C) ----------------------------------------------------
__int64 __fastcall IFDHTransmitToICC(unsigned int a1, int a2, __int64 a3, unsigned int a4, _WORD *a5, _DWORD *a6)
{
  _DWORD *v6; // r15
  unsigned int v7; // er12
  __int64 v8; // rbx
  unsigned int v9; // er14
  signed __int64 v10; // rax
  _BYTE *v11; // r14
  unsigned int v12; // ebx
  _BYTE *v14; // [rsp+10h] [rbp-30h]

  v6 = a6;
  v14 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a1 >> 16;
  tds_log_msg();
  if ( !v8 || !v7 )
  {
    tds_log_msg();
    v12 = 612;
    goto LABEL_13;
  }
  if ( !(*(_QWORD *)v8 ^ 0x5000DF040C08A400LL | *(unsigned __int8 *)(v8 + 8) ^ 0x32LL)
    || !(*(_QWORD *)v8 ^ 0xA0070004A400LL | *(unsigned __int8 *)(v8 + 8))
    || !(*(_QWORD *)v8 ^ 0xF092D30A0C04A400LL | *(unsigned __int8 *)(v8 + 8))
    || !(*(_QWORD *)v8 ^ 0xA00B0004A400LL | *(unsigned __int8 *)(v8 + 8) ^ 3LL) )
  {
    if ( ReaderData[448 * v9 + 21] )
    {
      *(_WORD *)v14 = -32150;
      *v6 = 2;
      return 0;
    }
LABEL_17:
    tds_log_msg();
    return 617;
  }
  v10 = 448LL * v9;
  if ( !ReaderData[v10 + 21] )
    goto LABEL_17;
  v11 = &ReaderData[v10];
  if ( a2 != 1 )
  {
    if ( !a2 )
    {
      tds_log_msg();
      lock_mutex((__int64)v11);
      v12 = PCSC_ABNTransmit((__int64)v11, v8, v7, v14, v6);
      if ( v12 )
        goto LABEL_22;
      goto LABEL_23;
    }
    tds_log_msg();
    v12 = 607;
LABEL_13:
    if ( v6 )
      *v6 = 0;
    return v12;
  }
  tds_log_msg();
  lock_mutex((__int64)v11);
  v12 = PCSC_ABNTransmit((__int64)v11, v8, v7, v14, v6);
  if ( v12 )
LABEL_22:
    tds_log_msg();
LABEL_23:
  unlock_mutex((__int64)v11);
  if ( (signed int)v12 <= -7 )
  {
    if ( v12 == -119 )
      return 616;
    if ( v12 != -17 )
      goto LABEL_29;
    return 617;
  }
  if ( v12 == -6 )
    return 613;
  if ( v12 )
LABEL_29:
    v12 = 612;
  return v12;
}

//----- (0000000000002186) ----------------------------------------------------
__int64 __fastcall IFDHControl(unsigned int a1, _BYTE *a2, unsigned __int8 *a3, int a4, void *a5, __int64 a6, _DWORD *a7)
{
  unsigned __int8 *v7; // r13
  unsigned int v8; // er14
  unsigned int v9; // er15
  signed __int64 v10; // r13
  _BYTE *v11; // r14
  unsigned int v12; // eax
  signed int v13; // er15
  char *v14; // rbx
  __int64 v15; // rax
  unsigned int v16; // eax
  unsigned int v17; // eax
  __int64 v18; // rbx
  unsigned int v19; // eax
  signed int v20; // eax
  unsigned int v21; // eax
  int v22; // er15
  int v23; // er14
  int v24; // ebx
  _BYTE *v25; // rbx
  unsigned int v26; // eax
  signed int v27; // eax
  _BYTE *v28; // r12
  unsigned int v29; // eax
  signed int v30; // eax
  __int64 v31; // rax
  unsigned int v32; // eax
  signed int v33; // eax
  unsigned __int8 *v34; // r15
  char *v35; // rdi
  unsigned __int8 v36; // al
  unsigned int v37; // eax
  signed int v38; // eax
  __int64 v39; // rdx
  __int64 v40; // r8
  __int64 v41; // r9
  char v42; // al
  int v43; // er12
  unsigned int v44; // er15
  signed int v45; // eax
  unsigned int *v46; // rbx
  unsigned int *v47; // r15
  unsigned int v48; // ebx
  unsigned int v49; // edi
  signed int v50; // eax
  unsigned int v51; // ebx
  signed int v52; // eax
  __int64 result; // rax
  __int64 v54; // [rsp+8h] [rbp-EC18h]
  __int64 v55; // [rsp+10h] [rbp-EC10h]
  __int64 v56; // [rsp+18h] [rbp-EC08h]
  __int64 v57; // [rsp+20h] [rbp-EC00h]
  __int64 v58; // [rsp+28h] [rbp-EBF8h]
  __int64 v59; // [rsp+30h] [rbp-EBF0h]
  __int64 v60; // [rsp+38h] [rbp-EBE8h]
  __int64 v61; // [rsp+40h] [rbp-EBE0h]
  __int64 v62; // [rsp+48h] [rbp-EBD8h]
  unsigned int v63; // [rsp+54h] [rbp-EBCCh]
  __int64 v64; // [rsp+58h] [rbp-EBC8h]
  void *v65; // [rsp+60h] [rbp-EBC0h]
  __int64 v66; // [rsp+68h] [rbp-EBB8h]
  _BYTE *v67; // [rsp+70h] [rbp-EBB0h]
  unsigned __int8 *v68; // [rsp+78h] [rbp-EBA8h]
  __int16 v69; // [rsp+86h] [rbp-EB9Ah]
  size_t v70; // [rsp+88h] [rbp-EB98h]
  char v71; // [rsp+90h] [rbp-EB90h]
  unsigned __int8 v72; // [rsp+91h] [rbp-EB8Fh]
  __int16 v73; // [rsp+92h] [rbp-EB8Eh]
  char v74; // [rsp+94h] [rbp-EB8Ch]
  char v75[2]; // [rsp+99h] [rbp-EB87h]
  char v76; // [rsp+9Bh] [rbp-EB85h]
  char v77; // [rsp+9Ch] [rbp-EB84h]
  __int64 v78; // [rsp+9Fh] [rbp-EB81h]
  __int16 v79; // [rsp+EAF0h] [rbp-130h]
  char v80; // [rsp+EAF2h] [rbp-12Eh]
  __int64 v81; // [rsp+EBF0h] [rbp-30h]

  v65 = a5;
  LODWORD(v66) = a4;
  v7 = a3;
  v67 = a2;
  v63 = a1;
  v8 = a1 >> 16;
  HIBYTE(v70) = 0;
  LODWORD(v70) = 0;
  v64 = 66305LL;
  v54 = 131841LL;
  v55 = 197377LL;
  v56 = 262913LL;
  v57 = 328449LL;
  v58 = 393985LL;
  v60 = 459521LL;
  v59 = 525057LL;
  tds_log_msg();
  tds_log_msg();
  v9 = v66;
  tds_log_msg();
  tds_log_msg();
  v68 = v7;
  tds_log_xxd();
  if ( (unsigned int)v66 >= 0x6403 )
  {
    *(_DWORD *)&ReaderData[448 * v8 + 9] = 10250;
    *a7 = 0;
    goto LABEL_84;
  }
  if ( (_DWORD)v67 == 1107298314 )
  {
    *a7 = 4;
    tds_log_msg();
    *(_DWORD *)v65 = *(_DWORD *)&ReaderData[448 * v8 + 9];
    tds_log_xxd();
    goto LABEL_84;
  }
  v10 = 448LL * v8;
  if ( !ReaderData[v10 + 21] )
    goto LABEL_83;
  v11 = &ReaderData[v10];
  switch ( (_DWORD)v67 )
  {
    case 0x42000801:
      tds_log_msg();
      *a7 = 0;
      *(_DWORD *)&ReaderData[v10 + 9] = 0;
      HIBYTE(v70) = 0;
      v12 = ABNED_Vendor_Transmit_Receive(
              (__int64)&ReaderData[v10],
              (__int64)&v54,
              0LL,
              0,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v13 = EvaluteStatus(v12, SHIBYTE(v70), &v79, 5);
      if ( v13 )
        goto LABEL_42;
      tds_log_msg();
      v14 = (char *)v65;
      memcpy(v65, &v79, (unsigned int)v70);
      v15 = (unsigned int)v70;
      *(_DWORD *)&v14[v15 + 3] = 3420206;
      *(_DWORD *)&v14[v15] = 774975520;
      *a7 = v70 + 7;
      tds_log_xxd();
      goto LABEL_81;
    case 0x42000802:
      tds_log_msg();
      *a7 = 0;
      HIBYTE(v70) = 0;
      *(_DWORD *)&ReaderData[v10 + 9] = 0;
      v69 = *(_WORD *)&v68[v9 - 2];
      v16 = ABNED_Vendor_Transmit_Receive(
              (__int64)v11,
              (__int64)&v64,
              (__int64)&v69,
              2,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v13 = EvaluteStatus(v16, SHIBYTE(v70), &v79, 1);
      if ( !v13 )
      {
        HIBYTE(v70) = 0;
        v17 = ABNED_Vendor_Transmit_Receive(
                (__int64)&ReaderData[v10],
                (__int64)&v55,
                0LL,
                0,
                (_BYTE *)&v70 + 7,
                (__int64)&v79,
                0x100u,
                (unsigned int *)&v70);
        v13 = EvaluteStatus(v17, SHIBYTE(v70), &v79, 4);
        if ( !v13 )
          goto LABEL_80;
      }
      goto LABEL_42;
    case 0x42000803:
      tds_log_msg();
      *(_QWORD *)&ReaderData[v10 + 9] = 0LL;
      *a7 = 0;
      HIBYTE(v70) = 0;
      v69 = *(_WORD *)&v68[v9 - 2];
      if ( v9 <= 1 )
        goto LABEL_70;
      v67 = &ReaderData[v10];
      v22 = v9 - 2;
      if ( v22 <= 0 )
        goto LABEL_70;
      v23 = v22;
      v24 = 0;
      do
      {
        v24 = GetDataBlock(v24, (__int64)v68, &v71);
        tds_log_msg();
      }
      while ( v24 < v22 && v24 != -1 );
      if ( v24 != v22 || !v22 || v24 == -1 )
        goto LABEL_70;
      v25 = v67;
      v26 = ABNED_Vendor_Transmit_Receive(
              (__int64)v67,
              (__int64)&v64,
              (__int64)&v69,
              2,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v27 = EvaluteStatus(v26, SHIBYTE(v70), &v79, 1);
      if ( v27 )
      {
        v13 = v27;
        goto LABEL_41;
      }
      HIBYTE(v70) = 0;
      v43 = 0;
      v44 = ABNED_Vendor_Transmit_Receive(
              (__int64)v25,
              (__int64)&v56,
              0LL,
              0,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      tds_log_xxd();
      v45 = EvaluteStatus(v44, SHIBYTE(v70), &v79, 2);
      v46 = (unsigned int *)&v70;
      if ( v45 )
      {
        v13 = v45;
        tds_log_msg();
        tds_log_msg();
        goto LABEL_42;
      }
      break;
    case 0x42000804:
      tds_log_msg();
      *a7 = 0;
      *(_QWORD *)&ReaderData[v10 + 9] = 0LL;
      v69 = 0;
      v18 = *v68;
      if ( (unsigned __int8)(*v68 - 1) >= 4u )
        goto LABEL_70;
      if ( (_DWORD)v18 + 1 == v9 )
      {
        v61 = v18 + 1;
        v28 = &ReaderData[v10];
        v62 = 0LL;
        tds_log_msg();
        v66 = 0LL;
      }
      else
      {
        if ( (_DWORD)v18 + 9 != v9 )
        {
LABEL_70:
          tds_log_msg();
          LOBYTE(v79) = 25;
          tds_log_msg();
          v42 = 25;
LABEL_71:
          ReaderData[v10 + 9] = 10;
          goto LABEL_72;
        }
        v61 = v18 + 1;
        v28 = &ReaderData[v10];
        tds_log_msg();
        LOBYTE(v31) = 2;
        v66 = v31;
        LOBYTE(v31) = 6;
        v62 = v31;
      }
      v32 = ABNED_Vendor_Transmit_Receive(
              (__int64)v28,
              (__int64)&v64,
              (__int64)&v69,
              2,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v33 = EvaluteStatus(v32, SHIBYTE(v70), &v79, 1);
      if ( v33 )
      {
        v13 = v33;
        goto LABEL_41;
      }
      *(_OWORD *)&v71 = 0LL;
      v78 = 0LL;
      v71 = 1;
      v67 = v28;
      v72 = v62 + v66 + 13;
      v73 = 14239;
      v74 = 4;
      v34 = v68;
      memcpy(&v75[-v18], v68 + 1, (unsigned int)v18);
      *(_WORD *)v75 = 671;
      v76 = v62;
      __memcpy_chk(&v77, &v34[v18 + 3], (unsigned __int8)v62, 59988LL);
      v35 = (char *)&v78 + (unsigned __int8)v62;
      *(_WORD *)(v35 - 3) = 10847;
      v36 = v66;
      *(v35 - 1) = v66;
      memcpy(v35, &v34[v61], v36);
      HIBYTE(v70) = 0;
      v37 = ABNED_Vendor_Transmit_Receive(
              (__int64)v67,
              (__int64)&v60,
              (__int64)&v71,
              23,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v38 = EvaluteStatus(v37, SHIBYTE(v70), &v79, 3);
      if ( v38 )
      {
        v13 = v38;
        goto LABEL_41;
      }
      goto LABEL_80;
    case 0x42000805:
      tds_log_msg();
      *(_QWORD *)&ReaderData[v10 + 9] = 0LL;
      v69 = 0;
      *a7 = 0;
      v19 = ABNED_Vendor_Transmit_Receive(
              (__int64)v11,
              (__int64)&v64,
              (__int64)&v69,
              2,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v20 = EvaluteStatus(v19, SHIBYTE(v70), &v79, 1);
      if ( v20 )
      {
        v13 = v20;
        goto LABEL_41;
      }
      v71 = 2;
      HIBYTE(v70) = 0;
      v29 = ABNED_Vendor_Transmit_Receive(
              (__int64)v11,
              (__int64)&v60,
              (__int64)&v71,
              1,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v30 = EvaluteStatus(v29, SHIBYTE(v70), &v79, 3);
      if ( !v30 )
        goto LABEL_80;
      v13 = v30;
      goto LABEL_41;
    case 0x42000806:
      tds_log_msg();
      *(_QWORD *)&ReaderData[v10 + 9] = 0LL;
      *a7 = 0;
      v21 = ABNED_Vendor_Transmit_Receive(
              (__int64)&ReaderData[v10],
              (__int64)&v59,
              (__int64)v68,
              v9,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              (unsigned int *)&v70);
      v13 = EvaluteStatus(v21, SHIBYTE(v70), &v79, 2);
      goto LABEL_42;
    default:
      *(_QWORD *)&ReaderData[v10 + 9] = 0LL;
      *a7 = 0;
      goto LABEL_81;
  }
  do
  {
    if ( v43 >= v23 )
    {
      HIBYTE(v70) = 0;
      v51 = ABNED_Vendor_Transmit_Receive(
              (__int64)v67,
              (__int64)&v58,
              0LL,
              0,
              (_BYTE *)&v70 + 7,
              (__int64)&v79,
              0x100u,
              v46);
      tds_log_xxd();
      v52 = EvaluteStatus(v51, SHIBYTE(v70), &v79, 3);
      if ( v52 )
      {
        v13 = v52;
        goto LABEL_41;
      }
LABEL_80:
      memcpy(v65, &v79, (unsigned int)v70);
      *a7 = v70;
      goto LABEL_81;
    }
    v66 = GetDataBlock(v43, (__int64)v68, &v71);
    v47 = v46;
    v48 = ABNED_Vendor_Transmit_Receive(
            (__int64)v67,
            (__int64)&v57,
            (__int64)&v71,
            (unsigned int)v72 + 2,
            (_BYTE *)&v70 + 7,
            (__int64)&v79,
            0x100u,
            v46);
    tds_log_xxd();
    v49 = v48;
    v46 = v47;
    v43 = v66;
    v50 = EvaluteStatus(v49, SHIBYTE(v70), &v79, 2);
  }
  while ( !v50 );
  v13 = v50;
LABEL_41:
  tds_log_msg();
LABEL_42:
  tds_log_msg();
  if ( v13 <= -1609564053 )
  {
    if ( v13 > -1609564142 )
    {
      switch ( v13 )
      {
        case -1609564141:
          ReaderData[v10 + 9] = 12;
          break;
        case -1609564140:
          ReaderData[v10 + 9] = 2;
          goto LABEL_82;
        case -1609564132:
          ReaderData[v10 + 9] = 9;
          break;
        default:
          goto LABEL_82;
      }
    }
    else
    {
      if ( v13 != -1609564159 )
      {
        if ( v13 != -1609564150 )
        {
          if ( v13 != -1609564147 )
            goto LABEL_82;
          ReaderData[v10 + 9] = 8;
          goto LABEL_62;
        }
        ReaderData[v10 + 9] = 1;
LABEL_81:
        tds_log_msg();
        goto LABEL_82;
      }
      ReaderData[v10 + 9] = 7;
    }
LABEL_62:
    ReaderData[v10 + 10] = v79;
    goto LABEL_82;
  }
  if ( (unsigned int)(v13 + 536862719) <= 4 )
  {
    switch ( v13 + 536862719 )
    {
      case 0:
        ReaderData[v10 + 9] = 5;
        goto LABEL_82;
      case 1:
        ReaderData[v10 + 9] = 4;
        goto LABEL_81;
      case 2:
        ReaderData[v10 + 9] = 3;
        closeDriver(v63, (__int64)"%s:%d:%s() ======ERROR CODE  %08x======", v39, (__int64)off_324C, v40, v41);
        goto LABEL_82;
      case 3:
      case 4:
LABEL_52:
        ReaderData[v10 + 9] = 3;
        goto LABEL_82;
      default:
        break;
    }
  }
  switch ( v13 + 535822336 )
  {
    case 0:
      goto LABEL_52;
    case 1:
      ReaderData[v10 + 9] = 11;
      ReaderData[v10 + 12] = v80;
      *(_WORD *)&ReaderData[v10 + 10] = v79;
      goto LABEL_82;
    case 2:
      ReaderData[v10 + 9] = 13;
      goto LABEL_65;
    case 3:
      v42 = v79;
      goto LABEL_71;
    default:
      if ( v13 != -1609564052 )
        goto LABEL_82;
      ReaderData[v10 + 9] = 6;
LABEL_65:
      v42 = v79;
      break;
  }
LABEL_72:
  ReaderData[v10 + 10] = v42;
LABEL_82:
  tds_log_msg();
  tds_log_msg();
LABEL_83:
  tds_log_msg();
LABEL_84:
  result = __stack_chk_guard;
  if ( __stack_chk_guard == v81 )
    result = 0LL;
  return result;
}
// 324C: using guessed type void *__ptr32 off_324C[5];
// 7230: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 2186: using guessed type char var_EB87[2];

//----- (0000000000003270) ----------------------------------------------------
__int64 __fastcall IFDHICCPresence(unsigned int a1)
{
  return 0x268 - (unsigned int)(*(_DWORD *)&ReaderData[448 * (a1 >> 16) + 228] == 0x267);
}

//----- (00000000000032A0) ----------------------------------------------------
__int64 __fastcall t1_init(__int64 a1)
{
  *(_QWORD *)(a1 + 20) = 0x100000003LL;
  *(_QWORD *)(a1 + 8) = 0xFF00000020LL;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 32) = csum_lrc_compute;
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 40) = 0;
  return 0LL;
}

//----- (00000000000032E3) ----------------------------------------------------
signed __int64 __fastcall t1_set_defaults(__int64 a1)
{
  signed __int64 result; // rax

  *(_DWORD *)(a1 + 20) = 3;
  result = 1095216660512LL;
  *(_QWORD *)(a1 + 8) = 1095216660512LL;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  return result;
}

//----- (0000000000003308) ----------------------------------------------------
signed __int64 __fastcall t1_set_param(__int64 a1, int a2, int a3)
{
  signed __int64 (__fastcall *v3)(__int64, __int64, _BYTE *); // rax
  signed __int64 result; // rax

  switch ( a2 )
  {
    case 2:
      *(_DWORD *)(a1 + 24) = 2;
      v3 = csum_crc_compute;
      goto LABEL_5;
    case 3:
      *(_DWORD *)(a1 + 24) = 1;
      v3 = csum_lrc_compute;
LABEL_5:
      *(_QWORD *)(a1 + 32) = v3;
      goto LABEL_10;
    case 4:
      *(_DWORD *)(a1 + 8) = a3;
      goto LABEL_10;
    case 5:
      *(_DWORD *)(a1 + 12) = a3;
      goto LABEL_10;
    case 6:
      *(_DWORD *)a1 = a3;
      goto LABEL_10;
    case 7:
      *(_BYTE *)(a1 + 40) = a3;
LABEL_10:
      result = 0LL;
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

//----- (000000000000337C) ----------------------------------------------------
__int64 __fastcall t1_compute_checksum(__int64 a1, __int64 a2, __int64 a3)
{
  return (unsigned int)a3 + (*(unsigned int (__fastcall **)(__int64, __int64, __int64))(a1 + 32))(a2, a3, a2 + a3);
}

//----- (000000000000339E) ----------------------------------------------------
void __fastcall t1_set_checksum(__int64 a1, int a2)
{
  signed __int64 (__fastcall *v2)(__int64, __int64, _BYTE *); // rax
  signed int v3; // ecx

  if ( a2 == 3 )
  {
    v2 = csum_lrc_compute;
    v3 = 1;
  }
  else
  {
    if ( a2 != 2 )
      return;
    v2 = csum_crc_compute;
    v3 = 2;
  }
  *(_DWORD *)(a1 + 24) = v3;
  *(_QWORD *)(a1 + 32) = v2;
}

//----- (00000000000033CF) ----------------------------------------------------
signed __int64 __fastcall t1_block_type(unsigned __int8 a1)
{
  unsigned int v1; // edx
  signed __int64 result; // rax

  v1 = 192;
  if ( a1 <= 0xBFu )
    v1 = 0;
  result = 128LL;
  if ( (a1 & 0xC0) != -128 )
    result = v1;
  return result;
}

//----- (00000000000033F1) ----------------------------------------------------
__int64 __fastcall t1_seq(unsigned int a1)
{
  unsigned int v1; // eax

  if ( (a1 & 0xC0) == -64 )
    return 0LL;
  if ( (a1 & 0xC0) == -128 )
    v1 = a1 >> 4;
  else
    v1 = a1 >> 6;
  return v1 & 1;
}

//----- (0000000000003418) ----------------------------------------------------
__int64 __fastcall t1_build(__int64 a1, _BYTE *a2, unsigned int a3, unsigned __int8 a4, __int64 a5, _QWORD *a6)
{
  __int64 v6; // rbx
  unsigned __int8 v7; // r15
  unsigned int v8; // er13
  _BYTE *v9; // r14
  unsigned int v10; // er12
  __int64 v11; // r8
  unsigned int v12; // esi
  unsigned __int8 v13; // al
  unsigned int v14; // ebx
  char v15; // dl
  __int64 v16; // rcx
  __int64 result; // rax
  _QWORD *v18; // [rsp+18h] [rbp-38h]

  v18 = a6;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = 0;
  tds_log_msg();
  tds_log_msg();
  v11 = v6;
  if ( v6 )
    v10 = *(_DWORD *)(v6 + 12) - *(_DWORD *)(v6 + 8);
  v12 = *(_DWORD *)(a1 + 8);
  v13 = v7 | 0x20;
  if ( v10 <= v12 )
    v13 = v7;
  v14 = v10;
  if ( v10 > v12 )
    v14 = *(_DWORD *)(a1 + 8);
  v15 = v13 & 0xC0;
  if ( (v13 & 0xC0) != -128 )
    v15 = ((v13 < 0xC0u) << 6) - 64;
  if ( v15 )
  {
    if ( v15 == -128 )
      v13 |= 16 * *(_BYTE *)(a1 + 5);
  }
  else
  {
    v13 |= *(_BYTE *)(a1 + 4) << 6;
    *(_BYTE *)(a1 + 40) = v10 > v12;
  }
  v16 = v8;
  *v9 = v8;
  v9[1] = v13;
  v9[2] = v14;
  if ( v14 )
    memcpy(v9 + 3, (const void *)(*(_QWORD *)v11 + *(unsigned int *)(v11 + 8)), v14);
  if ( v18 )
    *v18 = v14;
  result = (*(unsigned int (__fastcall **)(_BYTE *, _QWORD, _BYTE *, __int64, __int64))(a1 + 32))(
             v9,
             v14 + 3,
             &v9[v14 + 3],
             v16,
             v11)
         + v14
         + 3;
  *(_DWORD *)(a1 + 41) = *(_DWORD *)v9;
  return result;
}

//----- (000000000000355A) ----------------------------------------------------
__int64 __fastcall cur_buf_avail(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8));
}

//----- (0000000000003566) ----------------------------------------------------
__int64 __fastcall cur_buf_head(__int64 a1)
{
  return *(_QWORD *)a1 + *(unsigned int *)(a1 + 8);
}

//----- (0000000000003572) ----------------------------------------------------
signed __int64 __fastcall t1_rebuild(__int64 a1, _DWORD *a2)
{
  signed __int64 result; // rax

  result = 0LL;
  if ( (*(_BYTE *)(a1 + 42) & 0xC0) == -128 )
  {
    *a2 = *(_DWORD *)(a1 + 41);
    result = 4LL;
  }
  return result;
}

//----- (000000000000358F) ----------------------------------------------------
__int64 __fastcall cur_buf_init(_QWORD *a1, __int64 a2, int a3)
{
  __int64 result; // rax

  result = 0LL;
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = a2;
  *((_DWORD *)a1 + 4) = a3;
  return result;
}

//----- (00000000000035A5) ----------------------------------------------------
void __fastcall cur_buf_set(__int64 a1, __int64 a2, int a3)
{
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 12) = a3;
  tds_log_msg();
}

//----- (00000000000035F7) ----------------------------------------------------
signed __int64 __fastcall cur_buf_get(__int64 a1, void *a2, size_t a3)
{
  unsigned int v3; // er14
  void *v4; // rcx
  __int64 v5; // rsi
  signed __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = *(unsigned int *)(a1 + 8);
  result = 0xFFFFFFFFLL;
  if ( (unsigned int)(*(_DWORD *)(a1 + 12) - v5) >= a3 )
  {
    if ( v4 )
    {
      memcpy(v4, (const void *)(*(_QWORD *)a1 + v5), a3);
      LODWORD(v5) = *(_DWORD *)(a1 + 8);
    }
    *(_DWORD *)(a1 + 8) = v3 + v5;
    result = v3;
  }
  return result;
}

//----- (000000000000363D) ----------------------------------------------------
__int64 __fastcall cur_buf_put(__int64 a1, const void *a2, size_t a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  unsigned int v5; // er14

  v3 = a1;
  v4 = *(unsigned int *)(a1 + 12);
  if ( (unsigned int)(*(_DWORD *)(v3 + 16) - v4) >= a3 )
  {
    v5 = a3;
    if ( a2 )
    {
      memcpy((void *)(*(_QWORD *)v3 + v4), a2, a3);
      LODWORD(v4) = *(_DWORD *)(v3 + 12);
    }
    *(_DWORD *)(v3 + 12) = v5 + v4;
  }
  else
  {
    *(_DWORD *)(v3 + 20) = 1;
    v5 = -1;
  }
  return v5;
}

//----- (0000000000003687) ----------------------------------------------------
__int64 __fastcall cur_buf_putc(__int64 a1, char a2)
{
  char v3; // [rsp+Fh] [rbp-1h]

  v3 = a2;
  return cur_buf_put(a1, &v3, 1uLL);
}

//----- (00000000000036A9) ----------------------------------------------------
void __fastcall tds_log_msg()
{
  ;
}

//----- (00000000000036AF) ----------------------------------------------------
void tds_log_xxd()
{
  ;
}

//----- (00000000000036B8) ----------------------------------------------------
void __fastcall lock_mutex(__int64 a1)
{
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)) )
    tds_log_msg();
}

//----- (00000000000036F2) ----------------------------------------------------
void __fastcall unlock_mutex(__int64 a1)
{
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32)) )
    tds_log_msg();
}

//----- (000000000000372C) ----------------------------------------------------
void __fastcall cancel_lock_mutex(__int64 a1)
{
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)) )
    tds_log_msg();
}

//----- (0000000000003766) ----------------------------------------------------
void __fastcall cancel_unlock_mutex(__int64 a1)
{
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 96)) )
    tds_log_msg();
}

//----- (00000000000037A0) ----------------------------------------------------
__int64 __fastcall PCSC_GetCardStatus(__int64 device, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // ebx
  __int64 v7; // rax
  __int64 v8; // r9
  __int64 value; // [rsp+8h] [rbp-18h]

  v6 = device;
  value = 0x902LL;
  tds_log_msg();
  if ( (unsigned __int8)UsbIo_Write(v7, device, (__int64)&value, v8) )
  {
    tds_log_msg();
    LOBYTE(v6) = 1;
  }
  else
  {
    v6 = 0;
    tds_log_msg();
  }
  return v6;
}

//----- (0000000000003850) ----------------------------------------------------
__int64 __fastcall read_response(__int64 a1, _BYTE *a2, __int64 a3, unsigned int a4, unsigned int *a5, __int64 a6)
{
  unsigned int v6; // er13
  __int64 v7; // r15
  unsigned int v8; // ebx
  __int64 v9; // r9
  __int64 v10; // rcx
  unsigned int v12; // ebx
  unsigned int v13; // er14
  int v14; // er12
  unsigned int *v15; // [rsp+8h] [rbp-38h]
  __int64 v16; // [rsp+10h] [rbp-30h]

  v15 = a5;
  v6 = a4;
  v7 = a3;
  v16 = 0LL;
  tds_log_msg();
  if ( !(unsigned int)UsbIo_Read(a1, &v16) )
  {
    if ( (_BYTE)v16 == 1 )
    {
      *a2 = BYTE2(v16);
      *v15 = *(unsigned __int16 *)((char *)&v16 + 3);
      v9 = (unsigned __int8)*a2;
      tds_log_msg();
      if ( *v15 <= v6 )
      {
        if ( !*v15 )
        {
LABEL_16:
          v8 = 0;
          tds_log_msg();
          return v8;
        }
        v12 = 0;
        v13 = 0;
        while ( !(unsigned int)UsbIo_Read(a1, &v16) )
        {
          if ( (_BYTE)v16 )
            goto LABEL_7;
          v14 = BYTE1(v16);
          if ( (unsigned __int8)(BYTE1(v16) - 1) > 5u )
            goto LABEL_7;
          memcpy((void *)(v7 + v12), (char *)&v16 + 2, BYTE1(v16));
          v12 += v14;
          v13 += v14;
          if ( v13 >= *v15 )
            goto LABEL_16;
        }
        goto LABEL_2;
      }
      tds_log_msg();
    }
    else
    {
      v10 = *v15;
LABEL_7:
      tds_log_xxd();
    }
    return (unsigned int)-536862717;
  }
LABEL_2:
  tds_log_msg();
  return (unsigned int)-536862716;
}

//----- (0000000000003A51) ----------------------------------------------------
__int64 __fastcall write_command(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  unsigned __int64 v4; // r15
  __int64 v5; // r9
  int v6; // ecx
  unsigned int v7; // eax
  unsigned __int64 v8; // r14
  unsigned int v9; // er13
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // r9
  unsigned int v14; // ebx
  __int64 v16; // [rsp+0h] [rbp-40h]
  int v17; // [rsp+Ch] [rbp-34h]
  __int64 v18; // [rsp+10h] [rbp-30h]

  LODWORD(v4) = a4;
  v16 = a3;
  v18 = 0LL;
  tds_log_msg();
  *(_WORD *)(a2 + 3) = v4;
  if ( !(unsigned __int8)UsbIo_Write((unsigned int)v4, a1, a2, v5) )
  {
LABEL_20:
    tds_log_msg();
    return (unsigned int)-536862715;
  }
  if ( (_DWORD)v4 )
  {
    v7 = v4;
    v4 = (unsigned int)v4;
    LOBYTE(v6) = 1;
    LODWORD(v8) = 0;
    do
    {
      v17 = v6;
      LOBYTE(v18) = 0;
      v9 = v7;
      if ( (unsigned int)v8 >= v7 )
      {
        LOBYTE(v11) = 0;
      }
      else
      {
        v8 = (unsigned int)v8;
        v10 = (unsigned int)v8 - v4;
        if ( v10 <= 0xFFFFFFFFFFFFFFFALL )
          v10 = -6LL;
        memcpy((char *)&v18 + 2, (const void *)(v16 + (unsigned int)v8), -(signed __int64)v10);
        v11 = 0LL;
        do
        {
          ++v8;
          ++v11;
        }
        while ( v8 < v4 && v11 < 6 );
      }
      BYTE1(v18) = v11;
      tds_log_xxd();
      if ( !(unsigned __int8)UsbIo_Write(v12, a1, (__int64)&v18, v13) )
        goto LABEL_20;
      if ( *(_BYTE *)(a1 + 23) )
      {
        cancel_lock_mutex(a1);
        *(_BYTE *)(a1 + 23) = 0;
        cancel_unlock_mutex(a1);
      }
      v7 = v9;
      if ( (_DWORD)v8 == v9 )
        v6 = 0;
      else
        v6 = v17;
    }
    while ( v6 & 1 );
  }
  v14 = 0;
  tds_log_msg();
  return v14;
}

//----- (0000000000003C14) ----------------------------------------------------
__int64 __fastcall ABNED_Vendor_Transmit_Receive(__int64 a1, __int64 a2, __int64 a3, int a4, _BYTE *a5, __int64 a6, unsigned int a7, unsigned int *a8)
{
  __int64 v8; // r14
  _BYTE *v9; // r15
  unsigned int v10; // eax
  __int64 v11; // r9
  unsigned int v12; // er12
  unsigned int v13; // eax
  unsigned int v14; // er14

  v8 = a6;
  v9 = a5;
  v10 = write_command(a1, a2, a3, a4);
  if ( v10 )
  {
    v12 = v10;
    tds_log_msg();
  }
  else
  {
    v12 = 0;
    if ( v8 )
    {
      v13 = read_response(a1, v9, v8, a7, a8, v11);
      if ( v13 )
      {
        v14 = v13;
        tds_log_msg();
        v12 = v14;
      }
    }
  }
  return v12;
}

//----- (0000000000003CB5) ----------------------------------------------------
__int64 __fastcall PCSC_CAP_SendAndReceive(__int64 a1, __int64 a2, unsigned int a3, _BYTE *a4, _DWORD *a5, __int64 a6)
{
  _DWORD *v6; // rbx
  _BYTE *v7; // r15
  unsigned int v8; // er14
  int v9; // eax
  unsigned int v10; // ebx
  bool v11; // zf
  int v12; // eax
  unsigned int v13; // eax
  unsigned __int64 v14; // rax
  _DWORD *v15; // rsi
  signed __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rax
  _DWORD *v20; // rbx
  signed __int64 v21; // rdx
  __int64 result; // rax
  unsigned int v23; // ebx
  size_t v24; // rdx
  unsigned int *v25; // rbx
  __int64 v26; // rcx
  _DWORD *v27; // r12
  unsigned int v28; // ebx
  size_t v29; // rdx
  __int64 v30; // rcx
  char v31; // cl
  char v32; // cl
  __int64 v33; // [rsp+8h] [rbp-268h]
  __int64 v34; // [rsp+10h] [rbp-260h]
  __int16 v35; // [rsp+1Ah] [rbp-256h]
  unsigned int v36; // [rsp+1Ch] [rbp-254h]
  _DWORD *v37; // [rsp+20h] [rbp-250h]
  char v38; // [rsp+2Fh] [rbp-241h]
  __int128 v39; // [rsp+30h] [rbp-240h]
  __int128 v40; // [rsp+40h] [rbp-230h]
  __int128 v41; // [rsp+50h] [rbp-220h]
  __int128 v42; // [rsp+60h] [rbp-210h]
  __int128 v43; // [rsp+70h] [rbp-200h]
  __int128 v44; // [rsp+80h] [rbp-1F0h]
  __int128 v45; // [rsp+90h] [rbp-1E0h]
  __int128 v46; // [rsp+A0h] [rbp-1D0h]
  __int128 v47; // [rsp+B0h] [rbp-1C0h]
  __int128 v48; // [rsp+C0h] [rbp-1B0h]
  __int128 v49; // [rsp+D0h] [rbp-1A0h]
  __int128 v50; // [rsp+E0h] [rbp-190h]
  __int128 v51; // [rsp+F0h] [rbp-180h]
  __int128 v52; // [rsp+100h] [rbp-170h]
  __int128 v53; // [rsp+110h] [rbp-160h]
  __int128 v54; // [rsp+120h] [rbp-150h]
  char v55; // [rsp+130h] [rbp-140h]
  unsigned __int8 v56; // [rsp+131h] [rbp-13Fh]
  char v57; // [rsp+132h] [rbp-13Eh]
  __int64 v58; // [rsp+240h] [rbp-30h]

  v6 = a5;
  v7 = a4;
  v8 = a3;
  v33 = 459521LL;
  v34 = 66305LL;
  v38 = 0;
  v54 = 0LL;
  v53 = 0LL;
  v52 = 0LL;
  v51 = 0LL;
  v50 = 0LL;
  v49 = 0LL;
  v48 = 0LL;
  v47 = 0LL;
  v46 = 0LL;
  v45 = 0LL;
  v44 = 0LL;
  v43 = 0LL;
  v42 = 0LL;
  v41 = 0LL;
  v40 = 0LL;
  v39 = 0LL;
  v36 = 0;
  tds_log_msg();
  v9 = 0;
  if ( v8 == 5 )
  {
    LOBYTE(v9) = *(_DWORD *)a2 != 0x1001280;
    if ( !v9 )
    {
      tds_log_msg();
      *(_QWORD *)v7 = '002RCP\a';
      *((_WORD *)v7 + 4) = 0x9034u;
      v7[10] = 0;
      *v6 = 11;
LABEL_4:
      v10 = 0;
      tds_log_msg();
      goto LABEL_34;
    }
  }
  v11 = *(_DWORD *)a2 == 0x1021280;
  v37 = v6;
  if ( v11 )
  {
    tds_log_msg();
    v35 = 0;
    v13 = ABNED_Vendor_Transmit_Receive(a1, (__int64)&v34, (__int64)&v35, 2, &v38, (__int64)&v39, 0x100u, &v36);
    if ( v13 )
      goto LABEL_18;
    if ( v38 != 1 )
      goto LABEL_32;
    __bzero(&v55, 260LL);
    v55 = 1;
    v56 = *(_BYTE *)(a2 + 4);
    __memcpy_chk(&v57, a2 + 5, v56, 258LL);
    tds_log_xxd();
    v38 = 0;
    v54 = 0LL;
    v53 = 0LL;
    v52 = 0LL;
    v51 = 0LL;
    v50 = 0LL;
    v49 = 0LL;
    v48 = 0LL;
    v47 = 0LL;
    v46 = 0LL;
    v45 = 0LL;
    v44 = 0LL;
    v43 = 0LL;
    v42 = 0LL;
    v41 = 0LL;
    v40 = 0LL;
    v39 = 0LL;
    v13 = ABNED_Vendor_Transmit_Receive(
            a1,
            (__int64)&v33,
            (__int64)&v55,
            (unsigned int)v56 + 2,
            &v38,
            (__int64)&v39,
            0x100u,
            &v36);
    if ( v13 )
    {
LABEL_18:
      v10 = v13;
      if ( v13 + 536862719 > 1 )
        goto LABEL_34;
      goto LABEL_32;
    }
    LOBYTE(v18) = -16;
    LOBYTE(v19) = 105;
    if ( (unsigned __int8)(v38 - 6) >= 2u )
    {
      v20 = v37;
      if ( v38 == 3 )
      {
        __bzero(&v55, 260LL);
        v27 = v20;
        v28 = v36;
        __memcpy_chk(&v57, &v39, v36, 258LL);
        v55 = -63;
        v56 = v28;
        *(&v55 + v28 + 2) = -112;
        *(&v55 + v28 + 3) = 0;
        v29 = v28 + 4;
        v36 = v29;
        *v27 = v29;
        memcpy(v7, &v55, v29);
        v30 = (unsigned int)*v27;
        goto LABEL_40;
      }
      if ( v38 == 8 )
      {
        if ( (unsigned __int8)v39 > 0x29uLL )
          goto LABEL_69;
        v21 = 2199052681344LL;
        if ( _bittest64(&v21, (unsigned __int8)v39) )
        {
          LOBYTE(v18) = -15;
LABEL_60:
          *v7 = v19;
          v7[1] = v18;
          *v20 = 2;
          goto LABEL_33;
        }
        if ( (unsigned __int8)v39 == 25LL )
        {
          LOBYTE(v18) = -121;
          goto LABEL_60;
        }
        if ( (unsigned __int8)v39 != 33LL )
        {
LABEL_69:
          switch ( (_BYTE)v39 + 127 )
          {
            case 0:
            case 3:
              LOBYTE(v19) = 111;
              if ( BYTE1(v39) != 106 || (unsigned __int8)(BYTE2(v39) + 127) >= 8u )
                goto LABEL_59;
              v32 = 8 * (BYTE2(v39) + 127);
              v19 = 0x6A6F6F6F6F6A6A6AuLL >> v32;
              v18 = 0x8300000000838281LL >> v32;
              break;
            case 1:
              LOBYTE(v18) = -125;
              break;
            case 4:
              LOBYTE(v18) = -125;
              LOBYTE(v19) = 98;
              break;
            default:
              goto LABEL_58;
          }
          goto LABEL_60;
        }
        LOBYTE(v19) = 103;
      }
      else
      {
LABEL_58:
        LOBYTE(v19) = 111;
      }
LABEL_59:
      LOBYTE(v18) = 0;
      goto LABEL_60;
    }
    v20 = v37;
    goto LABEL_60;
  }
  v12 = 0;
  if ( v8 == 5 )
  {
    LOBYTE(v12) = *(_DWORD *)a2 != 16978560;
    if ( !v12 )
    {
      tds_log_msg();
      v54 = 0LL;
      v53 = 0LL;
      v52 = 0LL;
      v51 = 0LL;
      v50 = 0LL;
      v49 = 0LL;
      v48 = 0LL;
      v47 = 0LL;
      v46 = 0LL;
      v45 = 0LL;
      v44 = 0LL;
      v43 = 0LL;
      v42 = 0LL;
      v41 = 0LL;
      v40 = 0LL;
      v39 = 0LL;
      v35 = 0;
      v13 = ABNED_Vendor_Transmit_Receive(a1, (__int64)&v34, (__int64)&v35, 2, &v38, (__int64)&v39, 0x100u, &v36);
      if ( !v13 )
      {
        if ( v38 == 1 )
        {
          __bzero(&v55, 260LL);
          v54 = 0LL;
          v53 = 0LL;
          v52 = 0LL;
          v51 = 0LL;
          v50 = 0LL;
          v49 = 0LL;
          v48 = 0LL;
          v47 = 0LL;
          v46 = 0LL;
          v45 = 0LL;
          v44 = 0LL;
          v43 = 0LL;
          v42 = 0LL;
          v41 = 0LL;
          v40 = 0LL;
          v39 = 0LL;
          v55 = 2;
          v38 = 0;
          v13 = ABNED_Vendor_Transmit_Receive(a1, (__int64)&v33, (__int64)&v55, 1, &v38, (__int64)&v39, 0x100u, &v36);
          if ( !v13 )
          {
            if ( v38 != 3 )
            {
              LOBYTE(v14) = 105;
              if ( v38 != 6 )
              {
                v15 = v37;
                if ( v38 == 8 )
                {
                  if ( (unsigned __int8)v39 > 0x29uLL )
                    goto LABEL_70;
                  v16 = 2199052681344LL;
                  if ( _bittest64(&v16, (unsigned __int8)v39) )
                  {
                    LOBYTE(v17) = -15;
LABEL_50:
                    *v7 = v14;
                    v7[1] = v17;
                    *v15 = 2;
                    goto LABEL_33;
                  }
                  if ( (unsigned __int8)v39 == 25LL )
                  {
                    LOBYTE(v17) = -121;
                    goto LABEL_50;
                  }
                  if ( (unsigned __int8)v39 != 33LL )
                  {
LABEL_70:
                    switch ( (_BYTE)v39 + 127 )
                    {
                      case 0:
                      case 3:
                        LOBYTE(v14) = 111;
                        if ( BYTE1(v39) != 106 || (unsigned __int8)(BYTE2(v39) + 127) >= 8u )
                          goto LABEL_49;
                        v31 = 8 * (BYTE2(v39) + 127);
                        v14 = 0x6A6F6F6F6F6A6A6AuLL >> v31;
                        v17 = 0x8300000000838281LL >> v31;
                        break;
                      case 1:
                        LOBYTE(v17) = -125;
                        break;
                      case 4:
                        LOBYTE(v17) = -125;
                        LOBYTE(v14) = 98;
                        break;
                      default:
                        goto LABEL_48;
                    }
                    goto LABEL_50;
                  }
                  LOBYTE(v14) = 103;
                }
                else
                {
LABEL_48:
                  LOBYTE(v14) = 111;
                }
LABEL_49:
                LOBYTE(v17) = 0;
                goto LABEL_50;
              }
              LOBYTE(v17) = -16;
              v15 = v37;
              goto LABEL_50;
            }
            __bzero(&v55, 260LL);
            v23 = v36;
            __memcpy_chk(&v57, &v39, v36, 258LL);
            v55 = -63;
            v56 = v23;
            *(&v55 + v23 + 2) = -112;
            *(&v55 + v23 + 3) = 0;
            v24 = v23 + 4;
            v36 = v24;
            v25 = v37;
            *v37 = v24;
            memcpy(v7, &v55, v24);
            v26 = *v25;
LABEL_40:
            tds_log_xxd();
            goto LABEL_4;
          }
          goto LABEL_18;
        }
LABEL_32:
        *(_WORD *)v7 = -3991;
        *v37 = 2;
LABEL_33:
        v10 = 0;
        goto LABEL_34;
      }
      goto LABEL_18;
    }
  }
  v10 = 0;
  tds_log_msg();
  tds_log_xxd();
  if ( *(_BYTE *)a2 == -128 && *(_BYTE *)(a2 + 1) == 18 )
  {
    *(_WORD *)v7 = -31126;
    *v37 = 2;
    goto LABEL_4;
  }
  *(_WORD *)v7 = -32151;
  *v37 = 2;
LABEL_34:
  result = __stack_chk_guard;
  if ( __stack_chk_guard == v58 )
    result = v10;
  return result;
}
// 7224: using guessed type __int64 __fastcall __bzero(_QWORD, _QWORD);
// 7230: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000456C) ----------------------------------------------------
__int64 __fastcall PCSC_ABNTransmit(__int64 a1, __int64 a2, unsigned int a3, _BYTE *a4, _DWORD *a5)
{
  _DWORD *v5; // r14
  _BYTE *v6; // r15
  unsigned int v7; // er12
  __int64 v8; // r9
  unsigned int v9; // ebx

  v5 = a5;
  v6 = a4;
  v7 = a3;
  tds_log_msg();
  v9 = PCSC_CAP_SendAndReceive(a1, a2, v7, v6, v5, v8);
  tds_log_msg();
  return v9;
}

//----- (00000000000045FC) ----------------------------------------------------
__int64 __fastcall CardPowerOn(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // r9
  int v3; // ecx
  size_t v4; // rdx
  unsigned __int64 v5; // rax
  signed int v6; // edx
  int v7; // eax
  __int64 v8; // rdx
  unsigned __int64 v9; // r12
  unsigned int v10; // er14
  __int64 result; // rax
  __int64 v12; // [rsp+0h] [rbp-80h]
  unsigned __int64 v13; // [rsp+8h] [rbp-78h]
  __int64 v14; // [rsp+10h] [rbp-70h]
  int v15; // [rsp+1Ch] [rbp-64h]
  __int128 v16; // [rsp+20h] [rbp-60h]
  __int128 v17; // [rsp+30h] [rbp-50h]
  __int16 v18; // [rsp+40h] [rbp-40h]
  __int64 v19; // [rsp+50h] [rbp-30h]

  v12 = 258LL;
  tds_log_msg();
  v14 = 0LL;
  v17 = 0LL;
  v16 = 0LL;
  v18 = 0;
  if ( (unsigned __int8)UsbIo_Write(v1, a1, (__int64)&v12, v2) )
  {
    LOBYTE(v3) = 1;
    v15 = 0;
    while ( 1 )
    {
      LODWORD(v13) = v3;
      while ( 1 )
      {
        do
          tds_log_msg();
        while ( (unsigned int)UsbIo_Read(a1, &v14) );
        if ( (_BYTE)v14 != 2 )
          break;
        if ( BYTE1(v14) != -127 )
        {
          tds_log_msg();
          v10 = -114;
          goto LABEL_27;
        }
        if ( !BYTE2(v14) )
        {
          tds_log_msg();
          v10 = -119;
LABEL_27:
          tds_log_msg();
          goto LABEL_29;
        }
      }
      if ( (_BYTE)v14 )
        break;
      tds_log_msg();
      if ( (_BYTE)v13 )
      {
        if ( BYTE1(v14) == 1 )
        {
          tds_log_msg();
          v10 = -6;
          goto LABEL_27;
        }
        if ( (BYTE2(v14) | 4) != 63 )
          break;
      }
      if ( BYTE1(v14) )
      {
        v13 = BYTE1(v14);
        v4 = BYTE1(v14);
        if ( BYTE1(v14) <= 1u )
          v4 = 1LL;
        memcpy((char *)&v16 + v15, (char *)&v14 + 2, v4);
        v5 = 0LL;
        do
          ++v5;
        while ( v5 < v13 );
        v6 = v5 + v15;
      }
      else
      {
        v6 = v15;
      }
      v15 = v6;
      v7 = ParseATR(a1, &v16, v6);
      v3 = 0;
      if ( !v7 )
      {
        v10 = 0;
        printf("ATR Length: %d\n", *(unsigned int *)(a1 + 324), v8, 0LL, v12);
        printf("ATR: ", v12);
        if ( *(_DWORD *)(a1 + 324) )
        {
          v9 = 0LL;
          do
            printf("%02X ", *(unsigned __int8 *)(a1 + v9++ + 288), v12);
          while ( v9 < *(unsigned int *)(a1 + 324) );
        }
        putchar(10);
        goto LABEL_27;
      }
    }
    tds_log_msg();
    v10 = -114;
  }
  else
  {
    tds_log_msg();
    v10 = -5;
  }
LABEL_29:
  result = __stack_chk_guard;
  if ( __stack_chk_guard == v19 )
    result = v10;
  return result;
}

//----- (0000000000004958) ----------------------------------------------------
__int64 __fastcall CardPowerOff(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // er14
  __int64 v7; // rax
  __int64 v8; // r9
  __int64 v10; // [rsp+0h] [rbp-20h]

  v10 = 0xB02LL;
  v6 = 0;
  tds_log_msg();
  if ( (unsigned __int8)UsbIo_Write(v7, a1, (__int64)&v10, v8) )
  {
    tds_log_msg();
  }
  else
  {
    tds_log_msg();
    v6 = -5;
  }
  return v6;
}

//----- (0000000000004A0F) ----------------------------------------------------
__int64 __fastcall PCSC_CardPower(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( (_DWORD)a2 == 1 )
    return CardPowerOff(a1, a2, a3, a4, a5, a6);
  if ( (_DWORD)a2 )
    return 0LL;
  return CardPowerOn(a1);
}

//----- (0000000000004A2C) ----------------------------------------------------
signed __int64 __fastcall T0CmdParsing(__int64 a1, unsigned int a2, _DWORD *a3)
{
  signed __int64 result; // rax
  int v4; // er8
  int v5; // eax

  *a3 = 0;
  if ( a2 == 5 )
  {
    v5 = *(unsigned __int8 *)(a1 + 4);
    if ( !*(_BYTE *)(a1 + 4) )
    {
      *a3 = 258;
      return 0LL;
    }
    goto LABEL_7;
  }
  if ( a2 == 4 )
    goto LABEL_16;
  result = 612LL;
  if ( a2 < 6 )
    return result;
  v4 = *(unsigned __int8 *)(a1 + 4);
  if ( v4 + 5 == a2 )
  {
LABEL_16:
    *a3 = 2;
    return 0LL;
  }
  if ( a2 >= 7 && v4 + 6 == a2 )
  {
    v5 = *(unsigned __int8 *)(a1 + a2 - 1);
LABEL_7:
    *a3 = v5 + 2;
    return 0LL;
  }
  return result;
}

//----- (0000000000004A8E) ----------------------------------------------------
void *__fastcall Read_NamedPipeThreadRoutine(void *a1)
{
  int v1; // eax
  __int64 v2; // rax
  __int64 v3; // r9
  int v4; // ebx
  void *result; // rax
  __int64 v6; // [rsp+8h] [rbp-58h]
  char v7[8]; // [rsp+10h] [rbp-50h]
  char v8; // [rsp+19h] [rbp-47h]
  __int64 v9; // [rsp+20h] [rbp-40h]
  __int16 v10; // [rsp+28h] [rbp-38h]
  __int64 v11; // [rsp+30h] [rbp-30h]

  v6 = 1508097LL;
  strcpy(v7, "/tmp/abn_0");
  tds_log_msg();
  v1 = *((_DWORD *)a1 + 1);
  if ( v1 == 1 )
  {
    v8 = 49;
  }
  else if ( !v1 )
  {
    v8 = 48;
  }
  tds_log_msg();
  v10 = 0;
  v9 = 0LL;
  umask(0);
  if ( mkfifo(v7, 0x11B6u) < 0 && *__error() != 17 )
    tds_log_msg();
  while ( 1 )
  {
    v4 = open(v7, 0, 0LL);
    if ( v4 == -1 )
      tds_log_msg();
    if ( !*((_BYTE *)a1 + 21) )
    {
      tds_log_msg();
      goto LABEL_20;
    }
    v10 = 0;
    v9 = 0LL;
    read(v4, &v9, 8uLL);
    if ( v9 == 5642848040834195779LL )
    {
      tds_log_msg();
      tds_log_xxd();
      if ( (unsigned __int8)UsbIo_Write(v2, (__int64)a1, (__int64)&v6, v3) )
        goto LABEL_14;
      goto LABEL_13;
    }
    if ( v9 == 8100093801461148739LL )
      break;
LABEL_13:
    tds_log_msg();
LABEL_14:
    cancel_lock_mutex((__int64)a1);
    *((_BYTE *)a1 + 23) = 1;
    cancel_unlock_mutex((__int64)a1);
    close(v4);
  }
  tds_log_msg();
  cancel_lock_mutex((__int64)a1);
  *((_BYTE *)a1 + 23) = 1;
  cancel_unlock_mutex((__int64)a1);
LABEL_20:
  close(v4);
  cancel_lock_mutex((__int64)a1);
  *((_BYTE *)a1 + 25) = 1;
  cancel_unlock_mutex((__int64)a1);
  tds_log_msg();
  result = (void *)__stack_chk_guard;
  if ( __stack_chk_guard == v11 )
    result = 0LL;
  return result;
}

//----- (0000000000004DC9) ----------------------------------------------------
__int64 __usercall UsbIo_Write@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r9>)
{
  __int64 v4; // rbx
  int v5; // eax
  unsigned int v6; // er15

  v4 = a2;
  tds_log_msg();
  v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 184) + 216LL))(
         *(_QWORD *)(v4 + 184),
         *(unsigned __int8 *)(v4 + 205));
  if ( v5 )
  {
    if ( v5 != 0xE000404F )
    {
      (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(a2 + 192) + 200LL))(*(_QWORD *)(a2 + 192));
      LODWORD(v4) = 0;
      goto LABEL_7;
    }
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a2 + 184) + 360LL))(
      *(_QWORD *)(a2 + 184),
      *(unsigned __int8 *)(a2 + 205));
  }
  v6 = *(_DWORD *)(a2 + 164);
  tds_log_xxd();
  if ( !(*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64, _QWORD))(**(_QWORD **)(a2 + 184) + 256LL))(
          *(_QWORD *)(a2 + 184),
          *(unsigned __int8 *)(a2 + 205),
          a3,
          v6) )
  {
    tds_log_msg();
    LOBYTE(v4) = 1;
    return (unsigned int)v4;
  }
  LODWORD(v4) = 0;
LABEL_7:
  tds_log_msg();
  return (unsigned int)v4;
}

//----- (0000000000004F0B) ----------------------------------------------------
__int64 __usercall UsbIo_CloseDeviceAndInterface@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>)
{
  unsigned int v2; // ebx

  if ( (*(unsigned int (__cdecl **)(_QWORD))(**(_QWORD **)(a2 + 184) + 72LL))(*(_QWORD *)(a2 + 184)) )
    tds_log_msg();
  if ( (*(unsigned int (**)(void))(**(_QWORD **)(a2 + 184) + 24LL))() )
    tds_log_msg();
  if ( (*(unsigned int (**)(void))(**(_QWORD **)(a2 + 192) + 72LL))() )
    tds_log_msg();
  v2 = (*(__int64 (**)(void))(**(_QWORD **)(a2 + 192) + 24LL))();
  if ( v2 )
    tds_log_msg();
  return v2;
}

//----- (0000000000005007) ----------------------------------------------------
__int64 __fastcall Notify_Close_NamedPipe(__int64 a1)
{
  int v1; // eax
  int v2; // ebx
  char v4[8]; // [rsp+0h] [rbp-30h]
  char v5; // [rsp+9h] [rbp-27h]
  __int64 v6; // [rsp+10h] [rbp-20h]
  char v7; // [rsp+18h] [rbp-18h]

  strcpy(v4, "/tmp/abn_0");
  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 == 1 )
  {
    v5 = 49;
  }
  else if ( !v1 )
  {
    v5 = 48;
  }
  tds_log_msg();
  v6 = 8100093801461148739LL;
  v7 = 0;
  v2 = open(v4, 1, 0LL);
  if ( v2 == -1 )
    tds_log_msg();
  if ( write(v2, &v6, 8uLL) == -1 )
    tds_log_msg();
  else
    tds_log_msg();
  close(v2);
  return __stack_chk_guard;
}

//----- (000000000000518B) ----------------------------------------------------
void __fastcall UsbIo_AsynReadCompletionRoutine(__int64 a1, signed int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  char v7; // al
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // r9
  __int64 v12; // [rsp+0h] [rbp-30h]

  *(_QWORD *)(a1 + 13) = gBuffer;
  v12 = gBuffer;
  tds_log_msg();
  tds_log_msg();
  tds_log_xxd();
  if ( a2 > -536870164 )
  {
    switch ( a2 )
    {
      case -536870163:
        tds_log_msg();
        *(_WORD *)(a1 + 168) = 0;
        Notify_Close_NamedPipe(a1);
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 360LL))(
          *(_QWORD *)(a1 + 184),
          *(unsigned __int8 *)(a1 + 204));
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 360LL))(
          *(_QWORD *)(a1 + 184),
          *(unsigned __int8 *)(a1 + 205));
        if ( pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 176)) )
          tds_log_msg();
        *(_BYTE *)(a1 + 21) = 0;
        if ( pthread_cond_signal((pthread_cond_t *)(*(_QWORD *)(a1 + 176) + 64LL)) )
          tds_log_msg();
        LODWORD(v6) = pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176));
        if ( !(_DWORD)v6 )
          goto LABEL_38;
        break;
      case -536854449:
        tds_log_msg();
        *(_WORD *)(a1 + 168) = 0;
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 360LL))(
          *(_QWORD *)(a1 + 184),
          *(unsigned __int8 *)(a1 + 204));
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 360LL))(
          *(_QWORD *)(a1 + 184),
          *(unsigned __int8 *)(a1 + 205));
        Notify_Close_NamedPipe(a1);
        if ( pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 176)) )
          tds_log_msg();
        *(_BYTE *)(a1 + 21) = 0;
        if ( pthread_cond_signal((pthread_cond_t *)(*(_QWORD *)(a1 + 176) + 64LL)) )
          tds_log_msg();
        LODWORD(v6) = pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176));
        if ( !(_DWORD)v6 )
          goto LABEL_38;
        break;
      case 0:
        if ( !(_BYTE)v12 )
          goto LABEL_47;
        if ( (_BYTE)v12 != 1 )
        {
          if ( (_BYTE)v12 == 2 && BYTE1(v12) == -127 )
          {
            if ( BYTE2(v12) )
              *(_DWORD *)(a1 + 228) = 615;
            else
              *(_DWORD *)(a1 + 228) = 616;
            tds_log_msg();
            UsbIo_SetAsynRead(v8, a1, v9);
          }
LABEL_57:
          tds_log_msg();
          return;
        }
        if ( BYTE1(v12) != 3 )
          goto LABEL_47;
        v7 = BYTE2(v12);
        if ( BYTE2(v12) == 10 )
        {
          if ( !gContion )
          {
LABEL_59:
            tds_log_msg();
            UsbIo_SetAsynRead(v10, a1, v11);
            return;
          }
          tds_log_msg();
          if ( BYTE1(v12) != 3 )
          {
LABEL_47:
            if ( pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 176)) )
              tds_log_msg();
            if ( pthread_cond_signal((pthread_cond_t *)(*(_QWORD *)(a1 + 176) + 64LL)) )
              tds_log_msg();
            if ( pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176)) )
              tds_log_msg();
            tds_log_msg();
            goto LABEL_57;
          }
          v7 = BYTE2(v12);
        }
        if ( v7 == 6 )
        {
          if ( gContion )
          {
            tds_log_msg();
            goto LABEL_47;
          }
          goto LABEL_59;
        }
        goto LABEL_47;
      default:
LABEL_32:
        *(_WORD *)(a1 + 168) = 0;
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 360LL))(
          *(_QWORD *)(a1 + 184),
          *(unsigned __int8 *)(a1 + 204));
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 360LL))(
          *(_QWORD *)(a1 + 184),
          *(unsigned __int8 *)(a1 + 205));
        Notify_Close_NamedPipe(a1);
        if ( pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 176)) )
          tds_log_msg();
        *(_BYTE *)(a1 + 21) = 0;
        if ( pthread_cond_signal((pthread_cond_t *)(*(_QWORD *)(a1 + 176) + 64LL)) )
          tds_log_msg();
        LODWORD(v6) = pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176));
        if ( !(_DWORD)v6 )
          goto LABEL_38;
        break;
    }
    tds_log_msg();
LABEL_38:
    UsbIo_CloseDeviceAndInterface(v6, a1);
    return;
  }
  if ( a2 == -536870195 )
  {
    tds_log_msg();
    Notify_Close_NamedPipe(a1);
    *(_WORD *)(a1 + 168) = 0;
    return;
  }
  if ( a2 != -536870165 )
    goto LABEL_32;
  tds_log_msg();
  *(_WORD *)(a1 + 168) = 0;
  Notify_Close_NamedPipe(a1);
  if ( pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 176)) )
    tds_log_msg();
  *(_BYTE *)(a1 + 21) = 1;
  if ( pthread_cond_signal((pthread_cond_t *)(*(_QWORD *)(a1 + 176) + 64LL)) )
    tds_log_msg();
  if ( pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176)) )
    goto LABEL_57;
}
// B580: using guessed type __int64 gBuffer;
// B598: using guessed type char gContion;

//----- (000000000000594C) ----------------------------------------------------
void __usercall UsbIo_SetAsynRead(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<r9>)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  const char *v5; // rsi
  __int64 v6; // rax
  __int64 v7; // [rsp+0h] [rbp-10h]

  v7 = a1;
  v3 = a2;
  tds_log_msg();
  v4 = *(_QWORD *)(a2 + 184);
  if ( (*(unsigned int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v4 + 32LL))(v4, &v7) )
  {
    v5 = "%s:%d:%s() unable to create async event source (%08x)";
LABEL_5:
    tds_log_msg();
    (*(void (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(v3 + 184) + 72LL))(*(_QWORD *)(v3 + 184), v5);
    (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(v3 + 184) + 24LL))(*(_QWORD *)(v3 + 184));
    return;
  }
  v6 = CFRunLoopGetCurrent(v4);
  CFRunLoopAddSource(v6, v7, kCFRunLoopDefaultMode);
  gBuffer = 0LL;
  if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64 *, signed __int64, _QWORD, __int64))(**(_QWORD **)(v3 + 184)
                                                                                                  + 264LL))(
         *(_QWORD *)(v3 + 184),
         *(unsigned __int8 *)(v3 + 204),
         &gBuffer,
         8LL,
         UsbIo_AsynReadCompletionRoutine,
         v3) )
  {
    v5 = "%s:%d:%s() unable to do async bulk read, (%08x)";
    goto LABEL_5;
  }
  tds_log_msg();
}
// 71BE: using guessed type __int64 __fastcall CFRunLoopAddSource(_QWORD, _QWORD, _QWORD);
// 71C4: using guessed type __int64 __fastcall CFRunLoopGetCurrent(_QWORD);
// B580: using guessed type __int64 gBuffer;

//----- (0000000000005A7A) ----------------------------------------------------
__int64 __fastcall UsbIo_Read(__int64 a1, _QWORD *a2)
{
  unsigned int v2; // er14
  __int64 v4; // rax
  __int64 v5; // r9

  v2 = 2;
  tds_log_msg();
  *(_BYTE *)(a1 + 26) = 1;
  if ( pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 176)) )
    goto LABEL_2;
  tds_log_msg();
  gContion = 1;
  if ( pthread_cond_wait((pthread_cond_t *)(*(_QWORD *)(a1 + 176) + 64LL), *(pthread_mutex_t **)(a1 + 176)) )
  {
    if ( pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176)) )
      tds_log_msg();
    *(_BYTE *)(a1 + 26) = 0;
    gContion = 0;
    tds_log_msg();
    return 1;
  }
  tds_log_msg();
  gContion = 0;
  if ( !*(_BYTE *)(a1 + 21) )
  {
    if ( pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176)) )
      tds_log_msg();
    *(_BYTE *)(a1 + 26) = 0;
    free(*(void **)(a1 + 176));
    tds_log_msg();
    return 1;
  }
  *a2 = gBuffer;
  v2 = 0;
  tds_log_msg();
  LODWORD(v4) = pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 176));
  if ( (_DWORD)v4 )
  {
    v2 = 3;
  }
  else
  {
    *(_BYTE *)(a1 + 26) = 0;
    UsbIo_SetAsynRead(v4, a1, v5);
  }
LABEL_2:
  tds_log_msg();
  return v2;
}
// B580: using guessed type __int64 gBuffer;
// B598: using guessed type char gContion;

//----- (0000000000005D03) ----------------------------------------------------
void *__fastcall UsbIo_ThreadRoutine(void *a1)
{
  void *v1; // r14
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // r15
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // r15
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // rdi
  __int64 v14; // rsi
  int v16; // [rsp+0h] [rbp-20h]
  int v17; // [rsp+4h] [rbp-1Ch]

  v1 = a1;
  v16 = 2828;
  v17 = 30;
  tds_log_msg();
  if ( (unsigned int)IOMasterPort(0LL, &masterPort) || !masterPort )
  {
    tds_log_msg();
  }
  else
  {
    v2 = IOServiceMatching("IOUSBDevice");
    if ( v2 )
    {
      v3 = v2;
      v4 = kCFAllocatorDefault;
      v5 = CFNumberCreate(kCFAllocatorDefault, 3LL, &v16);
      CFDictionarySetValue(v3, CFSTR("idVendor"), v5);
      v6 = CFNumberCreate(v4, 3LL, &v17);
      CFDictionarySetValue(v3, CFSTR("idProduct"), v6);
      gNotifyPort = IONotificationPortCreate(masterPort);
      v7 = gNotifyPort;
      v8 = IONotificationPortGetRunLoopSource(gNotifyPort);
      v9 = CFRunLoopGetCurrent(v7);
      CFRunLoopAddSource(v9, v8, kCFRunLoopDefaultMode);
      v10 = CFRetain(v3, v8);
      v11 = IOServiceAddMatchingNotification(
              gNotifyPort,
              "IOServiceMatched",
              v10,
              UsbIo_SetAsynRead,
              0LL,
              &gSendAsynReadIter,
              *(_QWORD *)&v16);
      UsbIo_SetAsynRead(v11, (__int64)v1, v12);
      v13 = mach_task_self_;
      v14 = masterPort;
      mach_port_deallocate(mach_task_self_, masterPort);
      masterPort = 0;
      CFRunLoopRun(v13, v14);
      tds_log_msg();
    }
    else
    {
      tds_log_msg();
      mach_port_deallocate(mach_task_self_, masterPort);
    }
  }
  return 0LL;
}
// 71A6: using guessed type __int64 __fastcall CFDictionarySetValue(_QWORD, _QWORD, _QWORD);
// 71AC: using guessed type __int64 __fastcall CFNumberCreate(_QWORD, _QWORD, _QWORD);
// 71B8: using guessed type __int64 __fastcall CFRetain(_QWORD, _QWORD);
// 71BE: using guessed type __int64 __fastcall CFRunLoopAddSource(_QWORD, _QWORD, _QWORD);
// 71C4: using guessed type __int64 __fastcall CFRunLoopGetCurrent(_QWORD);
// 71CA: using guessed type __int64 __fastcall CFRunLoopRun(_QWORD, _QWORD);
// 71F4: using guessed type __int64 __fastcall IOMasterPort(_QWORD, _QWORD);
// 71FA: using guessed type __int64 __fastcall IONotificationPortCreate(_QWORD);
// 7200: using guessed type __int64 __fastcall IONotificationPortGetRunLoopSource(_QWORD);
// 7212: using guessed type __int64 __fastcall IOServiceAddMatchingNotification(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 721E: using guessed type __int64 __fastcall IOServiceMatching(_QWORD);
// B1B8: using guessed type __CFString cfstr_Idvendor;
// B1D8: using guessed type __CFString cfstr_Idproduct;
// B588: using guessed type __int64 gNotifyPort;

//----- (0000000000005EFB) ----------------------------------------------------
void __fastcall MySleepCallBack(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // r14
  int v5; // ebx
  __int64 v6; // rax
  __int64 v7; // r9
  bool v8; // zf
  __int64 v9; // [rsp+10h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v9 = 1508097LL;
  tds_log_msg();
  if ( v5 == -536870256 || v5 == -536870272 )
  {
    if ( *(_DWORD *)a1 )
    {
      v8 = *(_BYTE *)(a1 + 26) == 0;
      *(_DWORD *)a1 = 0;
      if ( !v8 && !(unsigned __int8)UsbIo_Write(v6, a1, (__int64)&v9, v7) )
        tds_log_msg();
    }
    goto LABEL_9;
  }
  if ( v5 == -536870288 )
LABEL_9:
    IOAllowPowerChange((unsigned int)root_port, v4);
}
// 71DC: using guessed type __int64 __fastcall IOAllowPowerChange(_QWORD, _QWORD);
// B59C: using guessed type int root_port;

//----- (0000000000005FC2) ----------------------------------------------------
void *__fastcall UsbIo_DetectSleepNotification(void *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rsi
  char v4; // [rsp+Ch] [rbp-14h]
  __int64 v5; // [rsp+10h] [rbp-10h]

  root_port = IORegisterForSystemPower(a1, &v5, MySleepCallBack, &v4);
  if ( root_port )
  {
    v1 = CFRunLoopGetCurrent(a1);
    v2 = IONotificationPortGetRunLoopSource(v5);
    CFRunLoopAddSource(v1, v2, kCFRunLoopCommonModes);
    CFRunLoopRun(v1, v2);
  }
  else
  {
    tds_log_msg();
  }
  return 0LL;
}
// 71BE: using guessed type __int64 __fastcall CFRunLoopAddSource(_QWORD, _QWORD, _QWORD);
// 71C4: using guessed type __int64 __fastcall CFRunLoopGetCurrent(_QWORD);
// 71CA: using guessed type __int64 __fastcall CFRunLoopRun(_QWORD, _QWORD);
// 7200: using guessed type __int64 __fastcall IONotificationPortGetRunLoopSource(_QWORD);
// 720C: using guessed type __int64 __fastcall IORegisterForSystemPower(_QWORD, _QWORD, _QWORD, _QWORD);
// B59C: using guessed type int root_port;

//----- (0000000000006045) ----------------------------------------------------
__int64 __usercall DetectSleepNotification@<rax>(void *a1@<rdi>, struct _opaque_pthread_t *a2@<rax>)
{
  unsigned int v2; // ebx
  pthread_t v4; // [rsp+0h] [rbp-10h]

  v4 = a2;
  v2 = (unsigned int)a1;
  tds_log_msg();
  if ( pthread_create(&v4, 0LL, (void *(__cdecl *)(void *))UsbIo_DetectSleepNotification, a1) )
  {
    v2 = 0;
    tds_log_msg();
  }
  else
  {
    tds_log_msg();
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (00000000000060E8) ----------------------------------------------------
__int64 __usercall UsbIo_CreateThread@<rax>(void *a1@<rdi>, struct _opaque_pthread_t *a2@<rax>)
{
  unsigned int v2; // ebx
  pthread_t v4; // [rsp+0h] [rbp-10h]

  v4 = a2;
  v2 = (unsigned int)a1;
  tds_log_msg();
  if ( pthread_create(&v4, 0LL, (void *(__cdecl *)(void *))UsbIo_ThreadRoutine, a1) )
  {
    v2 = 0;
    tds_log_msg();
  }
  else
  {
    tds_log_msg();
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (000000000000618B) ----------------------------------------------------
__int64 __usercall Read_Create_NamedPipeThread@<rax>(void *a1@<rdi>, struct _opaque_pthread_t *a2@<rax>)
{
  unsigned int v2; // ebx
  pthread_t v4; // [rsp+0h] [rbp-10h]

  v4 = a2;
  v2 = (unsigned int)a1;
  tds_log_msg();
  if ( pthread_create(&v4, 0LL, (void *(__cdecl *)(void *))Read_NamedPipeThreadRoutine, a1) )
  {
    v2 = 0;
    tds_log_msg();
  }
  else
  {
    tds_log_msg();
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (000000000000622E) ----------------------------------------------------
void __fastcall UsbIo_GetPipes(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // r14
  unsigned int v5; // ebx
  unsigned __int8 v6; // r13
  char v7; // r15
  char v8; // al
  bool v9; // cf
  char v10; // [rsp+11h] [rbp-2Fh]
  char v11; // [rsp+12h] [rbp-2Eh]
  char v12; // [rsp+13h] [rbp-2Dh]
  unsigned __int16 v13; // [rsp+14h] [rbp-2Ch]
  char v14; // [rsp+17h] [rbp-29h]

  v3 = a3;
  v4 = *(_QWORD *)(a3 + 184);
  tds_log_msg();
  if ( (_BYTE)a1 )
  {
    v5 = 1;
    v6 = 0;
    v7 = 0;
    while ( !(*(unsigned int (__fastcall **)(__int64, _QWORD, char *, char *, char *, unsigned __int16 *, char *))(*(_QWORD *)v4 + 208LL))(
               v4,
               (unsigned __int8)v5,
               &v14,
               &v10,
               &v11,
               &v13,
               &v12) )
    {
      v8 = v14;
      if ( !v7 && v14 == 1 )
      {
        *(_BYTE *)(v3 + 204) = v5;
        *(_DWORD *)(v3 + 160) = v13;
        v7 = v5;
      }
      if ( !(v6 | (unsigned __int8)v8) )
      {
        *(_BYTE *)(v3 + 205) = v5;
        *(_DWORD *)(v3 + 164) = v13;
        v6 = v5;
      }
      v9 = v5++ < a1;
      if ( !v9 )
        goto LABEL_10;
    }
    tds_log_msg();
    (*(void (__fastcall **)(__int64, const char *))(*(_QWORD *)v4 + 72LL))(
      v4,
      "%s:%d:%s() unable to get pipe properties for pipe %d, err = %08x");
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  }
  else
  {
LABEL_10:
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 184) + 240LL))(
      *(_QWORD *)(v3 + 184),
      *(unsigned __int8 *)(v3 + 204));
    tds_log_msg();
  }
}

//----- (000000000000638E) ----------------------------------------------------
void __fastcall UsbIo_GetInterface(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rax
  int v5; // eax
  __int64 v6; // rbx
  __int64 (__fastcall *v7)(__int64, __int64, __int64, char *); // r14
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rdx
  int v11; // er15
  __int64 v12; // rbx
  __int64 v13; // r14
  const char *v14; // rsi
  unsigned __int8 v15; // al
  char v16; // [rsp+0h] [rbp-50h]
  char v17; // [rsp+Ch] [rbp-44h]
  __int64 v18; // [rsp+10h] [rbp-40h]
  __int64 v19; // [rsp+18h] [rbp-38h]
  unsigned __int8 v20; // [rsp+27h] [rbp-29h]

  v19 = a3;
  tds_log_msg();
  v3 = CFUUIDGetConstantUUIDWithBytes(
         0LL,
         45LL,
         151LL,
         134LL,
         198LL,
         158LL,
         243LL,
         17LL,
         212LL,
         173LL,
         81LL,
         0LL,
         10LL,
         39LL,
         5LL,
         40LL,
         97LL);
  v4 = CFUUIDGetConstantUUIDWithBytes(
         0LL,
         194LL,
         68LL,
         232LL,
         88LL,
         16LL,
         156LL,
         17LL,
         212LL,
         145LL,
         212LL,
         0LL,
         80LL,
         228LL,
         198LL,
         66LL,
         111LL);
  v5 = IOCreatePlugInInterfaceForService(a1, v3, v4, &v18, &v17);
  v6 = v18;
  if ( v5
    || !v18
    || (v7 = *(__int64 (__fastcall **)(__int64, __int64, __int64, char *))(*(_QWORD *)v18 + 8LL),
        v8 = CFUUIDGetConstantUUIDWithBytes(
               0LL,
               115LL,
               201LL,
               122LL,
               232LL,
               158LL,
               243LL,
               17LL,
               212LL,
               177LL,
               208LL,
               0LL,
               10LL,
               39LL,
               5LL,
               40LL,
               97LL),
        v9 = CFUUIDGetUUIDBytes(v8),
        v11 = v7(v6, v9, v10, &v16),
        IODestroyPlugInInterface(v18),
        v12 = *(_QWORD *)&v16,
        v11)
    || !*(_QWORD *)&v16 )
  {
    tds_log_msg();
    return;
  }
  v13 = v19;
  *(_QWORD *)(v19 + 184) = *(_QWORD *)&v16;
  if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v12 + 64LL))(v12) )
  {
    tds_log_msg();
    return;
  }
  if ( (*(unsigned int (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(v13 + 184) + 152LL))(
         *(_QWORD *)(v13 + 184),
         &v20) )
  {
    v14 = "%s:%d:%s() dealWithInterface: unable to get number of endpoints. ret = %08x";
LABEL_11:
    tds_log_msg();
    (*(void (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(v13 + 184) + 72LL))(*(_QWORD *)(v13 + 184), v14);
    (*(void (**)(void))(**(_QWORD **)(v13 + 184) + 24LL))();
    return;
  }
  v15 = v20;
  if ( !v20 )
  {
    if ( (*(unsigned int (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v13 + 184) + 176LL))(
           *(_QWORD *)(v13 + 184),
           1LL) )
    {
      v14 = "%s:%d:%s() dealWithInterface: unable to set alternate interface 1. ret = %08x";
      goto LABEL_11;
    }
    if ( (*(unsigned int (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(v13 + 184) + 152LL))(
           *(_QWORD *)(v13 + 184),
           &v20) )
    {
      v14 = "%s:%d:%s() dealWithInterface: unable to get number of endpoints - alt setting 1. ret = %08x";
      goto LABEL_11;
    }
    v20 = 13;
    v15 = 13;
  }
  UsbIo_GetPipes(v15, (__int64)&v20, v13);
  tds_log_msg();
}
// 71D0: using guessed type __int64 __fastcall CFUUIDGetConstantUUIDWithBytes(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 71D6: using guessed type __int64 __fastcall CFUUIDGetUUIDBytes(_QWORD);
// 71E2: using guessed type __int64 __fastcall IOCreatePlugInInterfaceForService(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 71E8: using guessed type __int64 __fastcall IODestroyPlugInInterface(_QWORD);

//----- (00000000000066F6) ----------------------------------------------------
__int64 __fastcall UsbIo_GetDevice(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  int v5; // eax
  __int64 v6; // r15
  __int64 (__fastcall *v7)(__int64, __int64, __int64, char *); // r14
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // r10
  _WORD *v12; // r12
  unsigned __int64 v13; // r14
  __int64 v14; // rbx
  __int64 v15; // r14
  unsigned int v16; // ebx
  const char *v18; // rsi
  const char *v19; // rsi
  unsigned int v20; // ebx
  signed int v21; // er13
  unsigned int v22; // eax
  char v23; // [rsp+8h] [rbp-68h]
  char v24; // [rsp+10h] [rbp-60h]
  char v25; // [rsp+1Ch] [rbp-54h]
  __int64 v26; // [rsp+20h] [rbp-50h]
  __int64 v27; // [rsp+28h] [rbp-48h]
  __int64 v28; // [rsp+30h] [rbp-40h]
  __int16 v29; // [rsp+3Eh] [rbp-32h]
  unsigned int v30; // [rsp+40h] [rbp-30h]
  char v31; // [rsp+47h] [rbp-29h]

  v28 = a3;
  tds_log_msg();
  v3 = CFUUIDGetConstantUUIDWithBytes(
         0LL,
         157LL,
         199LL,
         183LL,
         128LL,
         158LL,
         192LL,
         17LL,
         212LL,
         165LL,
         79LL,
         0LL,
         10LL,
         39LL,
         5LL,
         40LL,
         97LL);
  v4 = CFUUIDGetConstantUUIDWithBytes(
         0LL,
         194LL,
         68LL,
         232LL,
         88LL,
         16LL,
         156LL,
         17LL,
         212LL,
         145LL,
         212LL,
         0LL,
         80LL,
         228LL,
         198LL,
         66LL,
         111LL);
  v5 = IOCreatePlugInInterfaceForService(a1, v3, v4, &v26, &v25);
  v6 = v26;
  if ( v5
    || !v26
    || (v7 = *(__int64 (__fastcall **)(__int64, __int64, __int64, char *))(*(_QWORD *)v26 + 8LL),
        v8 = CFUUIDGetConstantUUIDWithBytes(
               0LL,
               92LL,
               129LL,
               135LL,
               208LL,
               158LL,
               243LL,
               17LL,
               212LL,
               139LL,
               69LL,
               0LL,
               10LL,
               39LL,
               5LL,
               40LL,
               97LL),
        v9 = CFUUIDGetUUIDBytes(v8),
        LODWORD(v7) = v7(v6, v9, v10, &v23),
        IODestroyPlugInInterface(v26),
        v11 = *(_QWORD *)&v23,
        (_DWORD)v7)
    || !*(_QWORD *)&v23 )
  {
    tds_log_msg();
    return 1;
  }
  *(_QWORD *)(v28 + 192) = *(_QWORD *)&v23;
  if ( (*(unsigned int (__fastcall **)(__int64, __int16 *))(*(_QWORD *)v11 + 128LL))(v11, &v29) )
    tds_log_msg();
  tds_log_msg();
  v12 = (_WORD *)(a2 + 168);
  v13 = 0LL;
  do
  {
    v14 = (unsigned __int16)*v12;
    tds_log_msg();
    if ( *v12 == v29 )
    {
      v16 = 2;
LABEL_16:
      tds_log_msg();
      return v16;
    }
    ++v13;
    v12 += 224;
  }
  while ( v13 <= 1 );
  v15 = v28;
  *(_WORD *)(v28 + 168) = v29;
  if ( (*(unsigned int (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(v15 + 192) + 64LL))(
         *(_QWORD *)(v15 + 192),
         "%s:%d:%s() allReaders[%d].io.addr = %03i") )
  {
    tds_log_msg();
    return 1;
  }
  if ( (*(unsigned int (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v15 + 192) + 152LL))(*(_QWORD *)(v15 + 192), &v31)
    || !v31 )
  {
    v18 = "%s:%d:%s() Unable to obtain the number of configurations. ret = %08x";
    tds_log_msg();
    goto LABEL_27;
  }
  if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64 *))(**(_QWORD **)(v15 + 192) + 168LL))(
         *(_QWORD *)(v15 + 192),
         0LL,
         &v27) )
  {
    v18 = "%s:%d:%s() Unable to get config descriptor for index 0";
    goto LABEL_26;
  }
  if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v15 + 192) + 184LL))(
         *(_QWORD *)(v15 + 192),
         *(unsigned __int8 *)(v27 + 5)) )
  {
    v18 = "%s:%d:%s() Unable to set the configuration";
    goto LABEL_26;
  }
  v19 = &v24;
  *(_QWORD *)&v24 = -1LL;
  if ( !(*(unsigned int (__fastcall **)(_QWORD, char *, unsigned int *))(**(_QWORD **)(v15 + 192) + 224LL))(
          *(_QWORD *)(v15 + 192),
          &v24,
          &v30) )
  {
    v20 = IOIteratorNext(v30, &v24);
    if ( v20 )
    {
      do
      {
LABEL_33:
        UsbIo_GetInterface(v20, (__int64)v19, v15);
        IOObjectRelease(v20);
        v20 = IOIteratorNext(v30, v19);
      }
      while ( v20 );
    }
    else
    {
      v21 = -5;
      while ( ++v21 )
      {
        v19 = "%s:%d:%s() Reader not found. Retry!";
        tds_log_msg();
        usleep(0x2710u);
        v22 = IOIteratorNext(v30, "%s:%d:%s() Reader not found. Retry!");
        if ( v22 )
        {
          v20 = v22;
          v15 = v28;
          goto LABEL_33;
        }
      }
      tds_log_msg();
    }
    IOObjectRelease(v30);
    v30 = 0;
    v16 = 0;
    goto LABEL_16;
  }
  v18 = "%s:%d:%s() Unable to create interface iterator";
LABEL_26:
  tds_log_msg();
LABEL_27:
  (*(void (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(v15 + 192) + 72LL))(*(_QWORD *)(v15 + 192), v18);
  (*(void (**)(void))(**(_QWORD **)(v15 + 192) + 24LL))();
  return 1;
}
// 71D0: using guessed type __int64 __fastcall CFUUIDGetConstantUUIDWithBytes(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 71D6: using guessed type __int64 __fastcall CFUUIDGetUUIDBytes(_QWORD);
// 71E2: using guessed type __int64 __fastcall IOCreatePlugInInterfaceForService(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 71E8: using guessed type __int64 __fastcall IODestroyPlugInInterface(_QWORD);
// 71EE: using guessed type __int64 __fastcall IOIteratorNext(_QWORD, _QWORD);
// 7206: using guessed type __int64 __fastcall IOObjectRelease(_QWORD);

//----- (0000000000006C70) ----------------------------------------------------
__int64 __fastcall UsbIo_Open(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rbx
  unsigned int v7; // ebx
  __int64 v9; // rax
  __int64 v10; // r13
  __int64 v11; // r12
  __int64 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rbx
  unsigned int v16; // er13
  unsigned int v17; // eax
  unsigned int v18; // er12
  unsigned int v19; // ST00_4
  int v20; // eax
  int v21; // [rsp+Ch] [rbp-34h]
  int v22; // [rsp+10h] [rbp-30h]
  unsigned int v23; // [rsp+14h] [rbp-2Ch]

  v6 = a3;
  v21 = 2828;
  v22 = 30;
  v23 = 0;
  tds_log_msg();
  if ( v6 )
  {
    if ( strncmp("ABN AMRO e.dentifier2", v6, 0x15uLL) )
    {
      v7 = 0;
LABEL_4:
      tds_log_msg();
      return v7;
    }
    tds_log_msg();
    v22 = 30;
  }
  if ( (unsigned int)IOMasterPort(0LL, &masterPort) )
  {
    v7 = 0;
LABEL_8:
    tds_log_msg();
    return v7;
  }
  v9 = IOServiceMatching("IOUSBDevice");
  if ( !v9 )
  {
    v7 = 0;
    goto LABEL_4;
  }
  v10 = v9;
  v11 = kCFAllocatorDefault;
  v12 = CFNumberCreate(kCFAllocatorDefault, 3LL, &v21);
  if ( !v12 )
  {
    v7 = 0;
    goto LABEL_4;
  }
  v13 = v12;
  CFDictionaryAddValue(v10, CFSTR("idVendor"), v12);
  CFRelease(v13);
  v14 = CFNumberCreate(v11, 3LL, &v22);
  if ( !v14 )
  {
    v7 = 0;
    goto LABEL_4;
  }
  v15 = v14;
  CFDictionaryAddValue(v10, CFSTR("idProduct"), v14);
  CFRelease(v15);
  if ( (unsigned int)IOServiceGetMatchingServices(masterPort, v10, &v23) )
  {
    v7 = 0;
    goto LABEL_8;
  }
  v16 = 0;
  tds_log_msg();
  v17 = IOIteratorNext(v23, "%s:%d:%s() Before IOIteratorNext!");
  if ( v17 )
  {
    v7 = 0;
    while ( 1 )
    {
      v18 = v17;
      v19 = v16++;
      tds_log_msg();
      if ( v19 > 1 )
        break;
      v20 = UsbIo_GetDevice(v18, a1, a2);
      if ( v20 != 2 )
      {
        if ( !v20 )
        {
          tds_log_msg();
LABEL_28:
          IOObjectRelease(v23);
          v23 = 0;
          mach_port_deallocate(mach_task_self_, masterPort);
          masterPort = 0;
          tds_log_msg();
          LOBYTE(v7) = 1;
          return v7;
        }
        IOObjectRelease(v18);
      }
      v17 = IOIteratorNext(v23, a1);
      if ( !v17 )
        goto LABEL_28;
    }
  }
  else
  {
    IOObjectRelease(v23);
    v7 = 0;
    v23 = 0;
    mach_port_deallocate(mach_task_self_, masterPort);
    masterPort = 0;
    tds_log_msg();
    *(_BYTE *)(a2 + 21) = 0;
  }
  return v7;
}
// 71A0: using guessed type __int64 __fastcall CFDictionaryAddValue(_QWORD, _QWORD, _QWORD);
// 71AC: using guessed type __int64 __fastcall CFNumberCreate(_QWORD, _QWORD, _QWORD);
// 71B2: using guessed type __int64 __fastcall CFRelease(_QWORD);
// 71EE: using guessed type __int64 __fastcall IOIteratorNext(_QWORD, _QWORD);
// 71F4: using guessed type __int64 __fastcall IOMasterPort(_QWORD, _QWORD);
// 7206: using guessed type __int64 __fastcall IOObjectRelease(_QWORD);
// 7218: using guessed type __int64 __fastcall IOServiceGetMatchingServices(_QWORD, _QWORD, _QWORD);
// 721E: using guessed type __int64 __fastcall IOServiceMatching(_QWORD);
// B1B8: using guessed type __CFString cfstr_Idvendor;
// B1D8: using guessed type __CFString cfstr_Idproduct;

//----- (0000000000007045) ----------------------------------------------------
__int64 __fastcall UsbIo_Close(__int64 a1)
{
  unsigned int v1; // ebx
  int v2; // er14
  int v3; // eax
  int v4; // er14
  int v5; // eax

  v1 = a1;
  tds_log_msg();
  *(_WORD *)(a1 + 168) = 0;
  if ( !*(_BYTE *)(a1 + 21) )
    goto LABEL_12;
  v2 = (*(__int64 (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(a1 + 184) + 72LL))(
         *(_QWORD *)(a1 + 184),
         "%s:%d:%s() UsbIo_Close IN");
  v3 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 184) + 24LL))();
  if ( v2 )
  {
    v1 = 0;
    goto LABEL_7;
  }
  if ( !v3 )
  {
    v4 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 192) + 72LL))();
    v5 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 192) + 24LL))();
    if ( v4 )
    {
      v1 = 0;
      goto LABEL_7;
    }
    if ( v5 )
    {
      v1 = 0;
      goto LABEL_7;
    }
LABEL_12:
    tds_log_msg();
    LOBYTE(v1) = 1;
    return v1;
  }
  v1 = 0;
LABEL_7:
  tds_log_msg();
  return v1;
}

// ALL OK, 81 function(s) have been successfully decompiled
